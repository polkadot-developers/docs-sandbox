{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Substrate The Substrate Developer Hub provides a centralized location for developer resources and documentation to serve the Substrate developer community. The topics here are intended to help you learn what's possible when you build a Substrate blockchain and how Substrate can help you build a blockchain that best serves your specific project requirements or business model. Before you start building, though, you want to make sure you are in the right place. In Choosing a development platform , you'll learn how developing on a traditional smart contract platform differs from developing with Substrate and why Substrate might\u2014or might not\u2014suit your project requirements and goals. Blockchain basics provides context about the complexity associated with blockchain development and how Substrate simplifies the process by taking an approach that is modular, flexible, and interoperable. Topics in Fundamentals explain many of the core principles of the Substrate development environment and the design decisions that influence how you develop applications to run on a Substrate-based blockchain. After you digest the information in these introductory sections, you'll be ready to start designing, building, and testing your own custom blockchain solution.","title":"Welcome to Substrate"},{"location":"#welcome-to-substrate","text":"The Substrate Developer Hub provides a centralized location for developer resources and documentation to serve the Substrate developer community. The topics here are intended to help you learn what's possible when you build a Substrate blockchain and how Substrate can help you build a blockchain that best serves your specific project requirements or business model. Before you start building, though, you want to make sure you are in the right place. In Choosing a development platform , you'll learn how developing on a traditional smart contract platform differs from developing with Substrate and why Substrate might\u2014or might not\u2014suit your project requirements and goals. Blockchain basics provides context about the complexity associated with blockchain development and how Substrate simplifies the process by taking an approach that is modular, flexible, and interoperable. Topics in Fundamentals explain many of the core principles of the Substrate development environment and the design decisions that influence how you develop applications to run on a Substrate-based blockchain. After you digest the information in these introductory sections, you'll be ready to start designing, building, and testing your own custom blockchain solution.","title":"Welcome to Substrate"},{"location":"blockchain-basics/","text":"Blockchain basics","title":"Blockchain basics"},{"location":"blockchain-basics/#blockchain-basics","text":"","title":"Blockchain basics"},{"location":"fundamentals/","text":"Fundamentals","title":"Fundamentals"},{"location":"fundamentals/#fundamentals","text":"","title":"Fundamentals"},{"location":"quickstart/","text":"Quick start This Quick start assumes that you are setting up a development environment for the first time and want to try out running a single blockchain client\u2014called a node\u2014on your local computer. To keep things simple, you'll connect to the local node using a web browser and look up a balance for a predefined sample account. Before you begin Before you begin, verify the following: You have good internet connection and access to a shell terminal on your local computer. You are generally familiar with software development and using command-line interfaces.","title":"Quick start"},{"location":"quickstart/#quick-start","text":"This Quick start assumes that you are setting up a development environment for the first time and want to try out running a single blockchain client\u2014called a node\u2014on your local computer. To keep things simple, you'll connect to the local node using a web browser and look up a balance for a predefined sample account.","title":"Quick start"},{"location":"quickstart/#before-you-begin","text":"Before you begin, verify the following: You have good internet connection and access to a shell terminal on your local computer. You are generally familiar with software development and using command-line interfaces.","title":"Before you begin"},{"location":"community/","text":"Welcome to the Substrate developer community Thank you for your interest in contributing to documentation for the Substrate development framework. As a member of the community, you are invited and encouraged to contribute by submitting issues, offering suggestions for improvements to existing content, adding review comments to existing pull requests, proposing new content, or creating new pull requests to fix issues or provide new content. We value, respect, and appreciate all contributions from the developer community and only ask that you agree to abide by our Code of conduct and review our Contributor guidelines . To learn more about how to contribute, including guidelines for how to structure content and how to participate in our bounty program that pays you for contributing, see the following topics: Before you contribute Basic workflow for all contributions Contributor guidelines Writing guidelines Bounty program Before you contribute Before contributing, take a few minutes to review the contributor guidelines. The contributor guidelines are intended to make the contribution process easy and effective for everyone involved in addressing your issue, assessing changes, and finalizing your pull requests. Before contributing, consider the following: If you want to report an issue or request help, click Issues . You can also post a message to the community forum , ask a question on StackOverflow , or submit a support request. If you are reporting a bug, provide as much information about the problem as possible, including the version you are using. If you want to contribute directly to this repository, typical fixes might include any of the following: Spelling, grammar, or typo fixes. Code indentation, white space, or formatting changes. Broken or missing links. Note that any contribution to this repository must be submitted in the form of a pull request. If you are creating a pull request, be sure that the pull request only implements one bug fix. If you are new to working with GitHub repositories and creating pull requests, consider exploring First Contributions or How to Contribute to an Open Source Project on GitHub . Basic workflow for all contributions If you want to contribute in this repository, you should follow the recommended workflow and adhere to the best practices described in this section. Following the recommended workflow helps to ensure that updates and improvements can be integrated smoothly for all contributors and maintainers. Here's a summary of the steps to follow: Make sure you have a GitHub account, an internet connection, and access to a terminal shell or GitHub Desktop application for running commands. Clone the repository to your local machine or click Fork to create a copy of the repository under your GitHub account or organization name. Create a new branch for your fix by running a command similar to the following: bash git switch -c my-branch-name-here Open the file you want to fix in a text editor and make the appropriate changes for the issue you are trying to address. Add the file contents of the changed files to the index git uses to manage the state of the project by running a command similar to the following: bash git add path-to-changed-file Commit your changes to store the contents you added to the index along with a descriptive message by running a command similar to the following: bash git commit -m \"Description of the fix being committed.\" Push the changes to the remote repository by running a command similar to the following: bash git push origin my-branch-name-here Create a new pull request for the branch you pushed to the upstream GitHub repository. Be sure to provide a title that includes a short description of the changes made. After you submit the pull request, it needs to be reviewed and approved. Don't worry if your pull request is not immediately approved, for example, if changes are requested or if a reviewer asks for additional information. Make changes or add comments to the pull request, as needed. Celebrate your success after your pull request is merged! Contributor guidelines The most valuable contributions from the community typically take the form of how-to guides or tutorials that help other developers solve specific problems, learn specific skills, or demonstrate specific tasks. If you would like to contribute, you might be wondering \u201cWhat is the difference between a \u2018how-to\u2019 guide and a tutorial?\u201d. How-to guides A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do\u2014for example, open a bank account\u2014but not necessarily enough information to know how to do it\u2014for example, 1) select an institution, 2) fill out an application, 3) deposit a minimum amount of currency. How-to guides often include links to additional information, but should not include explanations that take the focus away from what the reader wants to accomplish. Tutorials A tutorial is a hands-on illustration or lesson that enables the reader to achieve a highly-predictable result. Tutorials assume that readers have no prior knowledge on the subject being covered and that they require explicit guidance to complete each step to reach a well-known outcome. Typically, a tutorial is a guided tour that helps the reader complete one organic task from start to finish. There are no detours and the information should not be broken out into subtopics because the steps must be completed in order, not in a sequence of the reader\u2019s choosing. The single most important aspect of a tutorial is that it should always result in a successful, expected outcome. The successful outcome is what inspires confidence and delight in the reader. The single most important distinction between a how-to guide and a tutorial is that in a tutorial the author decides what the goal should be and the author eliminates all distractions that would detract from the successful achievement of the goal. Recommendations for writing how-to guides The Substrate Developer Hub is intended to provide a modular and extensible framework of resources for the Substrate developer community and broader ecosystem. To achieve this goal, we want to make it easy for contributors to integrate new content that follows a few guiding principles and basic conventions for structure and style. As a content creator, you should keep the following general principles in mind: \u25fc\ufe0f Modularity. Each guide has a well-defined and useful focus. However, if there\u2019s information that\u2019s useful in more than one guide, you can abstract it into a standalone topic and reuse it in multiple places. \ud83d\udd17 Linking. Guides should use links where they are useful\u2014for example, to guide readers to concepts or reference topics\u2014but be mindful that stale links frustrate readers. \u23ef\ufe0f Examples. Useful code examples are a critical component of creating a useful guide. \ud83d\udef0\ufe0f Related references. Guides can include links to related resources, like Rust docs, video content, or other guides and tutorials. How-to guide template We recommend you use the how-to guide template to structure articles that you want to submit as to \u201chow-to\u201d topics. You can download a copy of the Markdown template directly from here . After downloading the template, rename the file and replace the description of each section with the relevant content. [Guide title] The guide title should summarize the goal of the article. For \u201chow-to\u201d guides, the title should complete the \u201cHow do I \u2026?\u201d sentence. The first paragraph of the article should provide a brief overview of what the article is about and why this information is useful to its audience. The overview section does not require a heading and it might be more than one paragraph. The opening section of each article sets the stage for what follows and should answer the obvious questions so readers can decide whether the content is relevant to them. Readers should know\u2014just from reading this section\u2014whether they should continue or the content doesn\u2019t apply to them and they should move on to something else. For your overview, try to answer the following questions: What is this article about? What is the purpose or goal to be accomplished by following the procedure or technique? Why would someone want to use this procedure or technique? For example, are there specific use case scenarios that are applicable? When would someone use this procedure? For example, is this an activity that is done once or repeated? Is it a pattern or a unique case? Where is the procedure or technique applicable? Who would use this procedure or technique? For example, are special skills required? Do specific permissions or restrictions apply? The overview section is also a good place to link to other resources, including other guides. As the content creator, you want readers to have confidence that the guide will be useful for them. Before you begin This section is optional but recommended . Use the Before you begin heading and use the section body to describe any prerequisites that apply to your article. This section should answer the following questions: What should someone have before reading this article? What should someone know before reading this article? What should someone do before reading this article? [Logical name for a set of steps] Instead of a generic Steps heading, describe what the steps accomplish. For most procedures and techniques, use clear, concise headings to describe each part of the procedure or technique. Use the generic Steps heading only if the article has one set of steps that achieve a single goal. For example, use Steps if an article is tightly focused on a single use case and a more descriptive heading would simply repeat the article title. For the content in this section: Each step should be action driven. In most cases, each step starts with a verb and ends with a period. The paragraph following a step should describe the result or outcome the reader should expect. If you feel a step needs any additional information, link to that information rather than embedding too much extraneous detail within the step. Code snippets can help illustrate the steps but should not overwhelm the focus on \"how do I do this\" not on \"what do I do\". Keep in mind that most steps have results and readers like confirmation that they have taken the correct action as they progress through a procedure. Examples Provide links to one or more code-based examples that make practical use of your article. This section should include at least one reference to a repository that exposes what this guide covers in the form of a working example. You can use reference an existing codebase within Substrate or new code in any publicly-available repository. Related resources This section is optional. If you include it, add a bulleted list of links to similar guides, other Developer Hub ressources, or related material. For example, you might add links to other how-to guides, tutorials, or Rust docs. Content categories and tags The How-to guides are grouped into categories to help keep them organized in the how-to-guides repository. The current groupings reflect the different areas of development within Substrate: Basics. Where the really simple guides live, those that can be referenced by more complex ones. Pallet design. Everything to do with building custom pallets with or without FRAME. Weights. Any content that covers configuring weights for specific use cases. Testing. A collection of guides for testing. Storage migrations. Anything to do with storage migrations. Consensus. Client stuff, bridging, node configurations. Parachains. WIP The source files use tags to identify the categories that apply. As a content contributor, you should use tags to identify the level of complexity and the most appropriate category for your content. Complexity Specify the level of complexity by adding the most appropriate tag from the following list: beginner intermediate advanced Information category Specify the category for your article by adding the most appropriate tag from the following list: basics client consensus currency fees frame-v1 migration node pallet design proof-of-work runtime storage testing weights","title":"Welcome to the Substrate developer community"},{"location":"community/#welcome-to-the-substrate-developer-community","text":"Thank you for your interest in contributing to documentation for the Substrate development framework. As a member of the community, you are invited and encouraged to contribute by submitting issues, offering suggestions for improvements to existing content, adding review comments to existing pull requests, proposing new content, or creating new pull requests to fix issues or provide new content. We value, respect, and appreciate all contributions from the developer community and only ask that you agree to abide by our Code of conduct and review our Contributor guidelines . To learn more about how to contribute, including guidelines for how to structure content and how to participate in our bounty program that pays you for contributing, see the following topics: Before you contribute Basic workflow for all contributions Contributor guidelines Writing guidelines Bounty program","title":"Welcome to the Substrate developer community"},{"location":"community/#before-you-contribute","text":"Before contributing, take a few minutes to review the contributor guidelines. The contributor guidelines are intended to make the contribution process easy and effective for everyone involved in addressing your issue, assessing changes, and finalizing your pull requests. Before contributing, consider the following: If you want to report an issue or request help, click Issues . You can also post a message to the community forum , ask a question on StackOverflow , or submit a support request. If you are reporting a bug, provide as much information about the problem as possible, including the version you are using. If you want to contribute directly to this repository, typical fixes might include any of the following: Spelling, grammar, or typo fixes. Code indentation, white space, or formatting changes. Broken or missing links. Note that any contribution to this repository must be submitted in the form of a pull request. If you are creating a pull request, be sure that the pull request only implements one bug fix. If you are new to working with GitHub repositories and creating pull requests, consider exploring First Contributions or How to Contribute to an Open Source Project on GitHub .","title":"Before you contribute"},{"location":"community/#basic-workflow-for-all-contributions","text":"If you want to contribute in this repository, you should follow the recommended workflow and adhere to the best practices described in this section. Following the recommended workflow helps to ensure that updates and improvements can be integrated smoothly for all contributors and maintainers. Here's a summary of the steps to follow: Make sure you have a GitHub account, an internet connection, and access to a terminal shell or GitHub Desktop application for running commands. Clone the repository to your local machine or click Fork to create a copy of the repository under your GitHub account or organization name. Create a new branch for your fix by running a command similar to the following: bash git switch -c my-branch-name-here Open the file you want to fix in a text editor and make the appropriate changes for the issue you are trying to address. Add the file contents of the changed files to the index git uses to manage the state of the project by running a command similar to the following: bash git add path-to-changed-file Commit your changes to store the contents you added to the index along with a descriptive message by running a command similar to the following: bash git commit -m \"Description of the fix being committed.\" Push the changes to the remote repository by running a command similar to the following: bash git push origin my-branch-name-here Create a new pull request for the branch you pushed to the upstream GitHub repository. Be sure to provide a title that includes a short description of the changes made. After you submit the pull request, it needs to be reviewed and approved. Don't worry if your pull request is not immediately approved, for example, if changes are requested or if a reviewer asks for additional information. Make changes or add comments to the pull request, as needed. Celebrate your success after your pull request is merged!","title":"Basic workflow for all contributions"},{"location":"community/#contributor-guidelines","text":"The most valuable contributions from the community typically take the form of how-to guides or tutorials that help other developers solve specific problems, learn specific skills, or demonstrate specific tasks. If you would like to contribute, you might be wondering \u201cWhat is the difference between a \u2018how-to\u2019 guide and a tutorial?\u201d.","title":"Contributor guidelines"},{"location":"community/#how-to-guides","text":"A how-to guide describes how to achieve a goal or complete a task. Only the information that is pertinent to achieving that goal or completing the task is included. With how-to guides, readers have enough information to know what they want to do\u2014for example, open a bank account\u2014but not necessarily enough information to know how to do it\u2014for example, 1) select an institution, 2) fill out an application, 3) deposit a minimum amount of currency. How-to guides often include links to additional information, but should not include explanations that take the focus away from what the reader wants to accomplish.","title":"How-to guides"},{"location":"community/#tutorials","text":"A tutorial is a hands-on illustration or lesson that enables the reader to achieve a highly-predictable result. Tutorials assume that readers have no prior knowledge on the subject being covered and that they require explicit guidance to complete each step to reach a well-known outcome. Typically, a tutorial is a guided tour that helps the reader complete one organic task from start to finish. There are no detours and the information should not be broken out into subtopics because the steps must be completed in order, not in a sequence of the reader\u2019s choosing. The single most important aspect of a tutorial is that it should always result in a successful, expected outcome. The successful outcome is what inspires confidence and delight in the reader. The single most important distinction between a how-to guide and a tutorial is that in a tutorial the author decides what the goal should be and the author eliminates all distractions that would detract from the successful achievement of the goal.","title":"Tutorials"},{"location":"community/#recommendations-for-writing-how-to-guides","text":"The Substrate Developer Hub is intended to provide a modular and extensible framework of resources for the Substrate developer community and broader ecosystem. To achieve this goal, we want to make it easy for contributors to integrate new content that follows a few guiding principles and basic conventions for structure and style. As a content creator, you should keep the following general principles in mind: \u25fc\ufe0f Modularity. Each guide has a well-defined and useful focus. However, if there\u2019s information that\u2019s useful in more than one guide, you can abstract it into a standalone topic and reuse it in multiple places. \ud83d\udd17 Linking. Guides should use links where they are useful\u2014for example, to guide readers to concepts or reference topics\u2014but be mindful that stale links frustrate readers. \u23ef\ufe0f Examples. Useful code examples are a critical component of creating a useful guide. \ud83d\udef0\ufe0f Related references. Guides can include links to related resources, like Rust docs, video content, or other guides and tutorials.","title":"Recommendations for writing how-to guides"},{"location":"community/#how-to-guide-template","text":"We recommend you use the how-to guide template to structure articles that you want to submit as to \u201chow-to\u201d topics. You can download a copy of the Markdown template directly from here . After downloading the template, rename the file and replace the description of each section with the relevant content.","title":"How-to guide template"},{"location":"community/#guide-title","text":"The guide title should summarize the goal of the article. For \u201chow-to\u201d guides, the title should complete the \u201cHow do I \u2026?\u201d sentence. The first paragraph of the article should provide a brief overview of what the article is about and why this information is useful to its audience. The overview section does not require a heading and it might be more than one paragraph. The opening section of each article sets the stage for what follows and should answer the obvious questions so readers can decide whether the content is relevant to them. Readers should know\u2014just from reading this section\u2014whether they should continue or the content doesn\u2019t apply to them and they should move on to something else. For your overview, try to answer the following questions: What is this article about? What is the purpose or goal to be accomplished by following the procedure or technique? Why would someone want to use this procedure or technique? For example, are there specific use case scenarios that are applicable? When would someone use this procedure? For example, is this an activity that is done once or repeated? Is it a pattern or a unique case? Where is the procedure or technique applicable? Who would use this procedure or technique? For example, are special skills required? Do specific permissions or restrictions apply? The overview section is also a good place to link to other resources, including other guides. As the content creator, you want readers to have confidence that the guide will be useful for them.","title":"[Guide title]"},{"location":"community/#before-you-begin","text":"This section is optional but recommended . Use the Before you begin heading and use the section body to describe any prerequisites that apply to your article. This section should answer the following questions: What should someone have before reading this article? What should someone know before reading this article? What should someone do before reading this article?","title":"Before you begin"},{"location":"community/#logical-name-for-a-set-of-steps","text":"Instead of a generic Steps heading, describe what the steps accomplish. For most procedures and techniques, use clear, concise headings to describe each part of the procedure or technique. Use the generic Steps heading only if the article has one set of steps that achieve a single goal. For example, use Steps if an article is tightly focused on a single use case and a more descriptive heading would simply repeat the article title. For the content in this section: Each step should be action driven. In most cases, each step starts with a verb and ends with a period. The paragraph following a step should describe the result or outcome the reader should expect. If you feel a step needs any additional information, link to that information rather than embedding too much extraneous detail within the step. Code snippets can help illustrate the steps but should not overwhelm the focus on \"how do I do this\" not on \"what do I do\". Keep in mind that most steps have results and readers like confirmation that they have taken the correct action as they progress through a procedure.","title":"[Logical name for a set of steps]"},{"location":"community/#examples","text":"Provide links to one or more code-based examples that make practical use of your article. This section should include at least one reference to a repository that exposes what this guide covers in the form of a working example. You can use reference an existing codebase within Substrate or new code in any publicly-available repository.","title":"Examples"},{"location":"community/#related-resources","text":"This section is optional. If you include it, add a bulleted list of links to similar guides, other Developer Hub ressources, or related material. For example, you might add links to other how-to guides, tutorials, or Rust docs.","title":"Related resources"},{"location":"community/#content-categories-and-tags","text":"The How-to guides are grouped into categories to help keep them organized in the how-to-guides repository. The current groupings reflect the different areas of development within Substrate: Basics. Where the really simple guides live, those that can be referenced by more complex ones. Pallet design. Everything to do with building custom pallets with or without FRAME. Weights. Any content that covers configuring weights for specific use cases. Testing. A collection of guides for testing. Storage migrations. Anything to do with storage migrations. Consensus. Client stuff, bridging, node configurations. Parachains. WIP The source files use tags to identify the categories that apply. As a content contributor, you should use tags to identify the level of complexity and the most appropriate category for your content.","title":"Content categories and tags"},{"location":"community/#complexity","text":"Specify the level of complexity by adding the most appropriate tag from the following list: beginner intermediate advanced","title":"Complexity"},{"location":"community/#information-category","text":"Specify the category for your article by adding the most appropriate tag from the following list: basics client consensus currency fees frame-v1 migration node pallet design proof-of-work runtime storage testing weights","title":"Information category"},{"location":"community/bounty/","text":"IMPORTANT: This section is still work in progress. There is no official Substrate Developer Hub bounty program at this time. To encourage community support and contributions to the developer ecosystem, we have established a bounty program. The bounty program provides prizes\u2014in the form of XXX\u2014to content developers who submit articles that expand and improve Substrate documentation by covering new \u201chow-to\u201d type topics. Participate To participate in the program: On the Issues page for the Substrate Developer Hub documentation repository, select the how-to guide and new content labels to filter the list of issues displayed. Select an issue that you are interested in that requires a guide. For example: How to call a function from another pallet How to use benchmarking to calculate weights If there isn\u2019t an issue for the topic you want to contribute, create an issue describing what you want to cover and at least one use case where it is applicable first. It\u2019s valuable to know the issues that are important to the community to help us prioritize the topics to cover. Use the how-to-guide template to organize the information for your topic. Be sure your article includes the following required sections. Overview Steps Examples If applicable , your article should also include the following sections: Use cases Before you begin Related resources Before submitting, verify your content meets the following requirements: Follows the how-to guide template structure. States a clear goal in the guide title or the overview section. Focuses on achieving the stated goal. Includes a link to working code or an example repo. Provides supporting references where relevant. Add the appropriate tags to describe your content [complexity] and [category]. Create a branch in the how-to-guides repository. Create a Pull Request (PR) for the article you want to contribute. Add the Bounty submission label to the PR for your article. Update the issue you selected or created with a link to the PR for your article. The article you submit will be evaluated as part of the Pull Request review and judged based on the following criteria: Usefulness. The material your article covers does not already exist and presents at least one clear use case. Structure. You\u2019ve followed the how-to guide template structure and the conventions described in the [contributor guidelines]. Correctness and completeness. Each step is clearly articulated, correct, and complete. Reproducibility. The steps achieve the expected result consistently.","title":"Bounties"},{"location":"community/bounty/#participate","text":"To participate in the program: On the Issues page for the Substrate Developer Hub documentation repository, select the how-to guide and new content labels to filter the list of issues displayed. Select an issue that you are interested in that requires a guide. For example: How to call a function from another pallet How to use benchmarking to calculate weights If there isn\u2019t an issue for the topic you want to contribute, create an issue describing what you want to cover and at least one use case where it is applicable first. It\u2019s valuable to know the issues that are important to the community to help us prioritize the topics to cover. Use the how-to-guide template to organize the information for your topic. Be sure your article includes the following required sections. Overview Steps Examples If applicable , your article should also include the following sections: Use cases Before you begin Related resources Before submitting, verify your content meets the following requirements: Follows the how-to guide template structure. States a clear goal in the guide title or the overview section. Focuses on achieving the stated goal. Includes a link to working code or an example repo. Provides supporting references where relevant. Add the appropriate tags to describe your content [complexity] and [category]. Create a branch in the how-to-guides repository. Create a Pull Request (PR) for the article you want to contribute. Add the Bounty submission label to the PR for your article. Update the issue you selected or created with a link to the PR for your article. The article you submit will be evaluated as part of the Pull Request review and judged based on the following criteria: Usefulness. The material your article covers does not already exist and presents at least one clear use case. Structure. You\u2019ve followed the how-to guide template structure and the conventions described in the [contributor guidelines]. Correctness and completeness. Each step is clearly articulated, correct, and complete. Reproducibility. The steps achieve the expected result consistently.","title":"Participate"},{"location":"community/site-building/","text":"This repository is used to build the documentation in the Substrate Developer Hub. Before you modify the structure or content in any way, be sure you know the conventions to follow and how to avoid making changes that break the site. New pages and moving files The i18n folder is used for translation and for the rendering of the navigation and elements sections. Your index.mdx file's title is not the source for this. If you are adding or renaming a page, you must add it correctly in src/components/DevNavMenu.tsx and possibly the gatsby-config.js and gatsby-node.js files. Internal link conventions All /rustdoc/ internal links must end with .html or .html#some-ID . Reasoning can be found in #425 . Check rendering images by clearing .cache From time to time, the development server local cache becomes corrupted. To fix this issue, run the following command: yarn clean && yarn dev PLEASE do this when reviewing a page before every PR - this ensures your state is what the build CI sees as well. New or updated yarn packages From time to time, BREAKING changes happen in the yarn dependencies. To fix this issue, run the following command: git checkout main && git pull && yarn install && yarn clean && yarn dev Change the branch above to your working brach of choice, or start a new on for a new PR based on latest main this way. NOTE: Discard the \"private\": false, field that this steps adds to the package.json file.","title":"Site builder guidelines"},{"location":"community/site-building/#new-pages-and-moving-files","text":"The i18n folder is used for translation and for the rendering of the navigation and elements sections. Your index.mdx file's title is not the source for this. If you are adding or renaming a page, you must add it correctly in src/components/DevNavMenu.tsx and possibly the gatsby-config.js and gatsby-node.js files.","title":"New pages and moving files"},{"location":"community/site-building/#internal-link-conventions","text":"All /rustdoc/ internal links must end with .html or .html#some-ID . Reasoning can be found in #425 .","title":"Internal link conventions"},{"location":"community/site-building/#check-rendering-images-by-clearing-cache","text":"From time to time, the development server local cache becomes corrupted. To fix this issue, run the following command: yarn clean && yarn dev PLEASE do this when reviewing a page before every PR - this ensures your state is what the build CI sees as well.","title":"Check rendering images by clearing .cache"},{"location":"community/site-building/#new-or-updated-yarn-packages","text":"From time to time, BREAKING changes happen in the yarn dependencies. To fix this issue, run the following command: git checkout main && git pull && yarn install && yarn clean && yarn dev Change the branch above to your working brach of choice, or start a new on for a new PR based on latest main this way. NOTE: Discard the \"private\": false, field that this steps adds to the package.json file.","title":"New or updated yarn packages"},{"location":"community/style-guide/","text":"This guide focuses on best practices for writing technical documentation and on the style conventions to use when developing documentation for Parity Technologies products and audiences. The goal of this guide is to help members of the documentation team and any one interested in contributing to documentation write material that is clear, concise, and consistent. This guide also includes peculiarities to working with this repo specifically for active contributors to be aware of available in the Builder notes section. If you can't find the answer to a style, voice, or terminology question in this guide, consult the following resources: Microsoft Style Guide Chicago Manual of Style Merriam-Webster Dictionary General guidance for writing engaging content There are three keys to writing content that engages the audience: Use the second person point of view to directly address the reader. Use an active voice and present tense whenever possible. Use a conversational tone that is not too formal or too chummy. Point of view In most cases, address the reader directly. For tutorials, use either first person plural\u2014we, us, our, ours\u2014or second person point of view. Because tutorials provide a more guided approach to a topic, using the first person plural is a more natural and commonly-accepted practice than in other types of documentation. Use the first person point of view sparingly and with intention. When overused, the first person narrative can overwhelm the sense of a shared experience and obscure the reader\u2019s journey. Do not use \u201cI\u201d or \u201cme\u201d unless it appears in the text of a user interface element. Do not use \u201cwe\u201d to refer to Parity or the Substrate Developer Hub team. For example, if you are documenting a recommended setting or practice, use \u201cParity Technologies recommends....\u201d not \u201cWe recommend...\u201d. Passive constructions In spite of the axiom to never use the passive voice, there are situations where a passive sentence structure might be appropriate. Don\u2019t twist a sentence into knots just to avoid a passive construction. Passive voice does have its place, but be wary of using it. When writing about software, it\u2019s often tempting to describe what\u2019s happening from the code point of view. However, there\u2019s almost always a human being with a goal or task to complete who is initiating the activity that the software is executing. If you keep this human presence in mind, your writing will be more dynamic, easier to follow, and more interesting to read. Contractions and conversational tone Contractions are generally acceptable because they give documentation a more natural conversational tone\u2014at least for English speakers. Be conscious of when and why you use contractions. To keep the tone conversational but concise, adhere to the following common-sense guidelines: Use common, well-known words whenever possible. Don\u2019t use flowery language or literary flourish words and phrases like \u201cand so forth\u201d, \u201calbeit\u201d, \u201cheretofore\u201d, or \u201cthus\u201d. Try to be precise in word choice. For example: Don\u2019t use \u201cwhen\u201d\u2014implying eventuality and time\u2014as interchangeable with \u201cif\u201d, which implies the possibility of something happening. Don\u2019t use phrases that introduce ambiguity. For example, instead of \u201cWhen the process completes...\u201d use \u201cAfter the process completes...\u201d. Think carefully about word choices like using \u201csince\u201d (implying a period of time) instead of \u201cbecause\u201d (implying cause and result) or using \u201conce\u201d (single occurrence) instead of \u201cafter\u201d (each time). Avoid using dead language words and phrases even if they are generally accepted as English words in practice. For example: Instead of \u201ci.e.\u201d, use \u201cthat is\u201d or rewrite the sentence to make the meaning clear without needing extra qualification. Instead of \u201ce.g.\u201d, use \u201cfor example\u201d. Instead of \u201cvia\u201d, use an appropriate English substitute such as \u201cby\u201d, \u201cthrough\u201d, or \u201cusing\u201d. Instead of \u201cetc.\u201d, use \u201cand so on\u201d or revise the content to make the term unnecessary. For example, revise to use such as or like followed by an example or two. Instead of \u201ccaveat\u201d, use an appropriate English substitute such as \u201cnotice\u201d, \u201ccaution\u201d, or \u201cwarning\u201d. Avoid adding unnecessary words or phrases. For example: Instead of \u201cIn order to\u201d, just use \u201cto\u201d. Instead of \u201cas well as\u201d, just use \u201cand\u201d. Instead of \u201cand then\u201d, just use \u201cthen\u201d. Avoid jargon, colloquialisms, and idiomatic phrases. Avoid adverbs and subjective statements. For example, don\u2019t use words and phrases that include easily, rapidly, simply, quickly. Experienced developers who truly prefer to skip the tutorial... We can quickly test if this code is functioning as expected... Headings All heading levels should use the following conventions: Use sentence style case. Use active, present tense verbs in headings wherever appropriate, especially in the context of tutorials and how-to guides. Serve as a summary of the content they contain. Avoid generic headings like overview and introduction, if possible. While generic heading can be conceptually useful, they add no value to the content or the navigational experience. Always contain content. A heading should never be immediately followed by another heading. As a best practice, avoid using headings strictly for navigation. Limit heading levels As a best practice, avoid building an information hierarchy with more than three heading levels. Most content can be effectively organized using two internal heading levels, making it easier to navigate and scan for relevant topics. Topic titles Avoid using gerunds (verbs that end with -ing) in titles and headings. Procedure titles and headings should answer the question: What are you trying to do? For example, if the answer to What are you trying to do? is I want to create an account , the article heading should be Create an account . In most cases, concept and reference topics are named with a noun phrase, such as Event hooks . Lists Introduce lists with a heading, a sentence, or a fragment that ends with a colon. Use numbered lists for processes and procedures that must be completed in sequential order. Use bulleted lists for items that don't need to appear in order. Make all list items parallel in structure. For example, start each item in the list using a noun or a phrase that starts with a verb. Bullets Bullets are for unordered lists. The order of items in a bulleted list can imply importance, but generally all list items are peers. Each list item should start with a capital letter and end with a period unless all of the list items are single words or short phrases of no more than four words. Use parallel structure in phrasing the items in a list. For example, each list item might start with a verb, noun, or gerund. Numbered steps Only use numbered paragraphs for steps in procedures. If a procedure has more than nine steps, always consider breaking it into subsections with headings. Ideally, each procedure or subtask should be three to six steps, not have nested sub-steps, and have minimal embedded paragraphs describing what happens\u2014the result or outcome to expect\u2014in an unnumbered paragraph following the step. Don't combine different actions into one step except when two actions complete a task, such as \"Enter the user name, then click Next .\" Pronouns Use gender-neutral pronouns, like \u201cthey\u201d whenever possible. Generally, you can change any noun from singular to plural to have subject-verb-pronoun agreement and avoid the use of gender-specific pronouns like \u201che\u201d, \u201chim\u201d, \u201chis\u201d or \u201cshe\u201d, \u201cher\u201d, \u201chers\u201d. Be wary of impersonal and potentially ambiguous pronouns such as: all, another, any each, either few, many, neither, none, one, other same, several, some, such that, them, these, those If you use any of these impersonal pronouns, be sure you answer \u201cof what?\u201d, \u201cof which?\u201d, or \u201cas what?\u201d in the sentence. Terminology and usage conventions This section covers common terminology, style, and usage questions and recommended practices. Above and below Don't use above to mean earlier or as an adjective preceding a noun ( the above section ) or following a noun ( the code above ). Use a hyperlink, or use previous , preceding , or earlier . Don't use below to mean later or as an adjective preceding a noun ( the below section ) or following a noun ( the code below ). Use a hyperlink, or use later or the following . For example: Use the preceding code to display information about the database. Use the following code to display information about the database. Dates and numbers Use the DD Mon YYYY or DD Month YYYY format for dates. In body text, spell out whole numbers from zero through nine. Use numerals for 10 or greater. Use commas in numbers with four or more digits. Use more than instead of over (over is a spatial term). Emphasis and admonitionments Use bold formatting for user interface elements that the user interacts with, including: Dialog titles Field labels Buttons labels Options displayed in the user interface Don't use bold, italics, or underlining for emphasis. If there's text that requires more attention than the surrounding body, consider isolating it as a standalone note or tip. Use admonishment components sparingly! They are generally disruptive to the reader\u2019s experience. Ask yourself if it is really necessary to stop the reader\u2019s forward progress by adding a Note, Caution, or Tip component. Note Indicates neutral or positive information that emphasizes or supplements important points of the main text. A note supplies information that may apply only in special cases. Examples are memory limitations, equipment configurations, or details that apply to specific versions of a program. Tip Helps users apply the techniques and procedures described in the text to their specific needs. A tip suggests alternative methods that may not be obvious and helps users understand the benefits and capabilities of the product. A tip is not essential to the basic understanding of the text. Caution Advises users that failure to take or avoid a specific action could result in loss of data. Images Diagrams and illustrations can help readers visualize and internalize complex ideas and processes. So, use them liberally but with intention. Images also help to break up long text flows, but they should always reinforce and reflect the text immediately preceding or immediately following the image. If you include screenshots, only include the relevant parts of the screen and use callouts to highlight how what is captured in the image is relevant to the text. Be wary of using diagrams or illustrations that include any information\u2014visual or textual\u2014that is likely to get stale. Log in formats Most Linux distributions and macOS use log in to describe how a user initiates an interactive session. Windows uses log on. Use log in as two words with no hyphen when describing an action (verb usage). Use login as one word when used as a noun (rare but some platforms use login to mean user or an identity). Use log-in with a hyphen when modifying a noun (adjective usage). Optional steps Use (Optional) to the beginning of steps that are optional. For example: Open a new terminal. Open the attributes file in a text editor. (Optional) Add a custom field. Punctuation Element How to use it apostrophe (\u2018) Use in contractions for a conversational tone. Avoid using the possessive form. capitalization Use sentence style capitalization for all headings. When referring to elements in the user interface, follow the capitalization that is used in the labels or text. Do not capitalize common terms. colon (:) Use a colon at the end of the statement that introduces a procedure, bulleted list, or table. comma (,) Use a serial comma to separate three or more items in a series, including the item before the conjunction. em dash (\u2014) Use an em dash (\u2014) to set off a parenthetical phrase with more emphasis than parentheses provide. Don\u2019t add spaces around an em dash. Don\u2019t capitalize the first word after an em dash unless the word is a proper noun. hyphenation (-) Avoid using hyphenated compound words. Use hyphens only if the meaning is unclear without them or if the only recognized form of the word includes a hyphen. quotation marks (\" \") Avoid using quotation marks unless you need to quote a message or as tring that would otherwise be confusing given its surrounding context. semicolons (;) Don't use semicolons instead of commas to separate items in a list. If you think the content should use semicolons, consider rewriting it into subtopics or an unordered bullet list. Slashes (/) and backslashes () Avoid using slashes or backslashes except when documenting paths that require either forward or backward slashes. Never use and/or in documentation. Software versions Use or later or and later to refer to multiple versions of software. For example: Firefox 3.6 or later Rust compiler (rustc) version 1.55.0 and later Tense Use present tense whenever possible. Use past tense only if you must describe something that has already occurred. Use future tense only if you must describe something that has not yet occurred but can be safely assumed. User interface elements In general, you should avoid writing about user interface elements. Instead, documentation should always focus on what the audience needs to do or wants to accomplish and not what is displayed on the screen. Element What to do button Use bold for the button label. Don't include \"button\" in the description. For example: Click Submit . checkbox Use checkbox, not box or check box, if you need to refer to a checkbox in the user interface. Use select and clear with checkboxes, not turn on and turn off, mark and unmark, check and uncheck, or unselect and deselect. click Use click to describe taking action on a standalone button. Do not use click on. Click and select are not interchangeable. dialog If you need to refer to a dialog box, use dialog. Don't use pop-up window, dialog box, or dialogue box. dropdown Use dropdown as an adjective, not as a noun. For example, use dropdown list . Verb usage Verb How to use it allow, enable Avoid using software as a point of view and consider rewriting to focus on the human interacting with the software. can, may, might Use the verb can when describing ability, capability, or capacity. Avoid using the verb may because it implies permission. Use the past tense might when describing the possibility or eventuality of an outcome. clear Use _ clear rather than deselect or unselect if you have to describe removing a selection from a checkbox. displays Use the transitive verb displays rather than the intransitive verb appears. Use displays with a direct object. For example, The command displays log messages. ensure Use ensure to mean to make sure or to guarantee. Remember that this is not interchangeable with assure (to make confident) and insure (to provide insurance). enter, type Use enter to instruct the user to input a value by pressing the Enter or Return key. Use type to instruct the user to type a value in a field. select Use select to describe taking action on a menu item, checkbox, or radio button. Note that click and select are not interchangeable. set up, setup Use set up \u2014two words, no hyphen\u2014when used as a verb. Don't hyphenate. Use setup \u2014one word, no hyphen\u2014when used as an adjective or as a noun. want, wish Use want instead of wish or desire when the user has a choice of actions. Word choice Word in question How to use it affect, effect Use affect as a verb and use effect as a noun. app, application Use application or applications unless there\u2019s a specific reason for using the shorthand term app or apps . back-end, front-end Using the hyphen in these terms is still more common than not using it. Both forms are acceptable, but for consistency use the hyphen. email It hasn\u2019t been e-mail for thirty-plus years. Never use emails. Don\u2019t use email as a verb. file name Use file name as two words, not filename . its, it\u2019s Use its as a possessive meaning belonging to or associated with an object or idea previously mentioned. Because it is a vague pronoun, be sure what it refers to can be easily identified. Use it\u2019s only as a contraction for it is or it has . please Avoid using please in documentation unless there\u2019s a specific reason for using it. For example, you might use please if quoting the content of a message that asks the user to do something inconvenient. prerequisite As a section title, use Before you begin instead. If you use prerequisite in the text, there\u2019s no hyphen. that, which Use that at the beginning of a clause that\u2019s necessary for the sentence to make sense. Don\u2019t put a comma before it. Don't use that when introducing a clause referring to people. Use who . Use which at the beginning of a clause that adds supporting or parenthetical information to a sentence. If you can omit the clause and the sentence still makes sense, use which , and put a comma before it. user name Use user name as two words, not username. Best practices and common mistakes This section highlights best practices and common mistakes to avoid. Make every word count Concise sentences are easier to read, comprehend, and translate. Use simple words with precise meanings. Remove words that don\u2019t add substance. Avoid using passive to be verbs like been and being. Avoid weak or vague verbs, such as have , make , and do . When in doubt, choose the simple word or phrase over a more formal or complex one. For example: Use this Not this use utilize, make use of remove extract, take away, eliminate tell inform, let know to in order to, as a means to also in addition connect establish connectivity Whenever possible, choose words that have one clear meaning. Omit unnecessary adverbs\u2014words that describe how, when, or where. Unless they're important to the meaning of a statement, leave them out. Be consistent Use one term consistently to represent one concept. For example, if you use extrinsic, dispatchable, and transaction interchangeably or ambiguously, you\u2019ll leave the reader confused and uncertain. If terminology changes, be prepared to root out old terminology. If you use words that can be both nouns and verbs\u2014for example, words like file, post, mark, screen, record, and report\u2014use sentence structure and context to eliminate ambiguity. Avoid dangling participles Participles are modifiers so they must have a noun to modify. A dangling participle is a participle that doesn\u2019t have a noun to modify. If you misplace or leave out the word being modified, you\u2019ll end up with a sentence that is difficult to understand, illogical, or ambiguous (though potentially amusing). Here are a few examples of sentences with dangling participles: Looking around the yard, dandelions sprouted in every corner. Walking through the kitchen, the smoke alarm was going off. Driving like a maniac, the deer was hit and killed. You can correct these sentences by bringing the participle phrase closer to the subject the phrase is intended to modify or changing the word order of the sentence to clarify who is doing what. You can also fix these types of problems by changing the tense or using the active voice. For example: Looking around the yard, I saw dandelions had sprouted in every corner. As I was walking through the kitchen, the smoke alarm was going off. Driving like a maniac, he hit a deer and killed it. Dangling prepositions In modern English, it\u2019s perfectly acceptable to end a sentence with a preposition. Don\u2019t twist a sentence into knots just to avoid using a preposition at the end. This is something you might be interested in. This is an example you should pay attention to. Cross-reference formats Most cross-references should include information that clarifies what the reader can expect to be found in the referenced topic. For cross-references to topics in the Substrate documentation, use the following formats: For more information about [task or concept], see [topic-title]. For cross-references in a glossary entry to other glossary entries, use the following format: See [topic]. For cross-references to external resources, use the title of the destination instead of the URL of the destination. Avoid using links to unnamed destinations. For example, don\u2019t use links like click here or see this article . Writing concept topics Concept topics answer \u201cwhy?\u201d and \u201cwhat is\u2026?\u201d questions. Use concept topics to: Explain abstract ideas. Introduce new terminology. Offer analysis. Provide background information. The goal of a concept topic is to help the reader understand the bigger picture, the key components of a system or architecture, relationships between components. Concept topics tend to be relatively stable, requiring little, if any, ongoing maintenance. At a minimum, a concept topic includes at least one heading and one or more body paragraphs. A concept topic can also include: One or more examples. Two or more subsections, marked by subheadings. A list of related topics. Builder notes This repository has some conventions and peculiarities that you need to take into account when modifying it (in any way). Please read this entire section to avoid common gotchas and help make your life and the maintainers lives easier. New pages and moving files The i18n folder is used for translation but also for the rendering of the navigation elements sections . Your index.mdx file's title is not the source for this. If you are adding or renaming a page, you must add it correctly in src/components/DevNavMenu.tsx and possibly gatsby-config.js and gatsby-node.js . Internal link conventions All /rustdoc/ internal links must end with .html or .html#some-ID . Reasoning can be found in #425 . Check rendering images by clearing .cache From time to time, the development server local cache becomes corrupted. To fix this in a one liner: yarn clean && yarn dev PLEASE do this when reviewing a page before every PR - this ensures your state is what the build CI see as well. New or updated yarn packages From time to time, BREAKING changes happen in the yarn dependencies. To fix this in a one liner on main : git checkout main && git pull && yarn install && yarn clean && yarn dev Change the branch above to your working brach of choice, or start a new on for a new PR based on latest main this way. NOTE: please discard the \"private\": false, field this adds to package.json .","title":"Writing style guidelines"},{"location":"community/style-guide/#general-guidance-for-writing-engaging-content","text":"There are three keys to writing content that engages the audience: Use the second person point of view to directly address the reader. Use an active voice and present tense whenever possible. Use a conversational tone that is not too formal or too chummy.","title":"General guidance for writing engaging content"},{"location":"community/style-guide/#point-of-view","text":"In most cases, address the reader directly. For tutorials, use either first person plural\u2014we, us, our, ours\u2014or second person point of view. Because tutorials provide a more guided approach to a topic, using the first person plural is a more natural and commonly-accepted practice than in other types of documentation. Use the first person point of view sparingly and with intention. When overused, the first person narrative can overwhelm the sense of a shared experience and obscure the reader\u2019s journey. Do not use \u201cI\u201d or \u201cme\u201d unless it appears in the text of a user interface element. Do not use \u201cwe\u201d to refer to Parity or the Substrate Developer Hub team. For example, if you are documenting a recommended setting or practice, use \u201cParity Technologies recommends....\u201d not \u201cWe recommend...\u201d.","title":"Point of view"},{"location":"community/style-guide/#passive-constructions","text":"In spite of the axiom to never use the passive voice, there are situations where a passive sentence structure might be appropriate. Don\u2019t twist a sentence into knots just to avoid a passive construction. Passive voice does have its place, but be wary of using it. When writing about software, it\u2019s often tempting to describe what\u2019s happening from the code point of view. However, there\u2019s almost always a human being with a goal or task to complete who is initiating the activity that the software is executing. If you keep this human presence in mind, your writing will be more dynamic, easier to follow, and more interesting to read.","title":"Passive constructions"},{"location":"community/style-guide/#contractions-and-conversational-tone","text":"Contractions are generally acceptable because they give documentation a more natural conversational tone\u2014at least for English speakers. Be conscious of when and why you use contractions. To keep the tone conversational but concise, adhere to the following common-sense guidelines: Use common, well-known words whenever possible. Don\u2019t use flowery language or literary flourish words and phrases like \u201cand so forth\u201d, \u201calbeit\u201d, \u201cheretofore\u201d, or \u201cthus\u201d. Try to be precise in word choice. For example: Don\u2019t use \u201cwhen\u201d\u2014implying eventuality and time\u2014as interchangeable with \u201cif\u201d, which implies the possibility of something happening. Don\u2019t use phrases that introduce ambiguity. For example, instead of \u201cWhen the process completes...\u201d use \u201cAfter the process completes...\u201d. Think carefully about word choices like using \u201csince\u201d (implying a period of time) instead of \u201cbecause\u201d (implying cause and result) or using \u201conce\u201d (single occurrence) instead of \u201cafter\u201d (each time). Avoid using dead language words and phrases even if they are generally accepted as English words in practice. For example: Instead of \u201ci.e.\u201d, use \u201cthat is\u201d or rewrite the sentence to make the meaning clear without needing extra qualification. Instead of \u201ce.g.\u201d, use \u201cfor example\u201d. Instead of \u201cvia\u201d, use an appropriate English substitute such as \u201cby\u201d, \u201cthrough\u201d, or \u201cusing\u201d. Instead of \u201cetc.\u201d, use \u201cand so on\u201d or revise the content to make the term unnecessary. For example, revise to use such as or like followed by an example or two. Instead of \u201ccaveat\u201d, use an appropriate English substitute such as \u201cnotice\u201d, \u201ccaution\u201d, or \u201cwarning\u201d. Avoid adding unnecessary words or phrases. For example: Instead of \u201cIn order to\u201d, just use \u201cto\u201d. Instead of \u201cas well as\u201d, just use \u201cand\u201d. Instead of \u201cand then\u201d, just use \u201cthen\u201d. Avoid jargon, colloquialisms, and idiomatic phrases. Avoid adverbs and subjective statements. For example, don\u2019t use words and phrases that include easily, rapidly, simply, quickly. Experienced developers who truly prefer to skip the tutorial... We can quickly test if this code is functioning as expected...","title":"Contractions and conversational tone"},{"location":"community/style-guide/#headings","text":"All heading levels should use the following conventions: Use sentence style case. Use active, present tense verbs in headings wherever appropriate, especially in the context of tutorials and how-to guides. Serve as a summary of the content they contain. Avoid generic headings like overview and introduction, if possible. While generic heading can be conceptually useful, they add no value to the content or the navigational experience. Always contain content. A heading should never be immediately followed by another heading. As a best practice, avoid using headings strictly for navigation.","title":"Headings"},{"location":"community/style-guide/#limit-heading-levels","text":"As a best practice, avoid building an information hierarchy with more than three heading levels. Most content can be effectively organized using two internal heading levels, making it easier to navigate and scan for relevant topics.","title":"Limit heading levels"},{"location":"community/style-guide/#topic-titles","text":"Avoid using gerunds (verbs that end with -ing) in titles and headings. Procedure titles and headings should answer the question: What are you trying to do? For example, if the answer to What are you trying to do? is I want to create an account , the article heading should be Create an account . In most cases, concept and reference topics are named with a noun phrase, such as Event hooks .","title":"Topic titles"},{"location":"community/style-guide/#lists","text":"Introduce lists with a heading, a sentence, or a fragment that ends with a colon. Use numbered lists for processes and procedures that must be completed in sequential order. Use bulleted lists for items that don't need to appear in order. Make all list items parallel in structure. For example, start each item in the list using a noun or a phrase that starts with a verb.","title":"Lists"},{"location":"community/style-guide/#bullets","text":"Bullets are for unordered lists. The order of items in a bulleted list can imply importance, but generally all list items are peers. Each list item should start with a capital letter and end with a period unless all of the list items are single words or short phrases of no more than four words. Use parallel structure in phrasing the items in a list. For example, each list item might start with a verb, noun, or gerund.","title":"Bullets"},{"location":"community/style-guide/#numbered-steps","text":"Only use numbered paragraphs for steps in procedures. If a procedure has more than nine steps, always consider breaking it into subsections with headings. Ideally, each procedure or subtask should be three to six steps, not have nested sub-steps, and have minimal embedded paragraphs describing what happens\u2014the result or outcome to expect\u2014in an unnumbered paragraph following the step. Don't combine different actions into one step except when two actions complete a task, such as \"Enter the user name, then click Next .\"","title":"Numbered steps"},{"location":"community/style-guide/#pronouns","text":"Use gender-neutral pronouns, like \u201cthey\u201d whenever possible. Generally, you can change any noun from singular to plural to have subject-verb-pronoun agreement and avoid the use of gender-specific pronouns like \u201che\u201d, \u201chim\u201d, \u201chis\u201d or \u201cshe\u201d, \u201cher\u201d, \u201chers\u201d. Be wary of impersonal and potentially ambiguous pronouns such as: all, another, any each, either few, many, neither, none, one, other same, several, some, such that, them, these, those If you use any of these impersonal pronouns, be sure you answer \u201cof what?\u201d, \u201cof which?\u201d, or \u201cas what?\u201d in the sentence.","title":"Pronouns"},{"location":"community/style-guide/#terminology-and-usage-conventions","text":"This section covers common terminology, style, and usage questions and recommended practices.","title":"Terminology and usage conventions"},{"location":"community/style-guide/#above-and-below","text":"Don't use above to mean earlier or as an adjective preceding a noun ( the above section ) or following a noun ( the code above ). Use a hyperlink, or use previous , preceding , or earlier . Don't use below to mean later or as an adjective preceding a noun ( the below section ) or following a noun ( the code below ). Use a hyperlink, or use later or the following . For example: Use the preceding code to display information about the database. Use the following code to display information about the database.","title":"Above and below"},{"location":"community/style-guide/#dates-and-numbers","text":"Use the DD Mon YYYY or DD Month YYYY format for dates. In body text, spell out whole numbers from zero through nine. Use numerals for 10 or greater. Use commas in numbers with four or more digits. Use more than instead of over (over is a spatial term).","title":"Dates and numbers"},{"location":"community/style-guide/#emphasis-and-admonitionments","text":"Use bold formatting for user interface elements that the user interacts with, including: Dialog titles Field labels Buttons labels Options displayed in the user interface Don't use bold, italics, or underlining for emphasis. If there's text that requires more attention than the surrounding body, consider isolating it as a standalone note or tip. Use admonishment components sparingly! They are generally disruptive to the reader\u2019s experience. Ask yourself if it is really necessary to stop the reader\u2019s forward progress by adding a Note, Caution, or Tip component.","title":"Emphasis and admonitionments"},{"location":"community/style-guide/#note","text":"Indicates neutral or positive information that emphasizes or supplements important points of the main text. A note supplies information that may apply only in special cases. Examples are memory limitations, equipment configurations, or details that apply to specific versions of a program.","title":"Note"},{"location":"community/style-guide/#tip","text":"Helps users apply the techniques and procedures described in the text to their specific needs. A tip suggests alternative methods that may not be obvious and helps users understand the benefits and capabilities of the product. A tip is not essential to the basic understanding of the text.","title":"Tip"},{"location":"community/style-guide/#caution","text":"Advises users that failure to take or avoid a specific action could result in loss of data.","title":"Caution"},{"location":"community/style-guide/#images","text":"Diagrams and illustrations can help readers visualize and internalize complex ideas and processes. So, use them liberally but with intention. Images also help to break up long text flows, but they should always reinforce and reflect the text immediately preceding or immediately following the image. If you include screenshots, only include the relevant parts of the screen and use callouts to highlight how what is captured in the image is relevant to the text. Be wary of using diagrams or illustrations that include any information\u2014visual or textual\u2014that is likely to get stale.","title":"Images"},{"location":"community/style-guide/#log-in-formats","text":"Most Linux distributions and macOS use log in to describe how a user initiates an interactive session. Windows uses log on. Use log in as two words with no hyphen when describing an action (verb usage). Use login as one word when used as a noun (rare but some platforms use login to mean user or an identity). Use log-in with a hyphen when modifying a noun (adjective usage).","title":"Log in formats"},{"location":"community/style-guide/#optional-steps","text":"Use (Optional) to the beginning of steps that are optional. For example: Open a new terminal. Open the attributes file in a text editor. (Optional) Add a custom field.","title":"Optional steps"},{"location":"community/style-guide/#punctuation","text":"Element How to use it apostrophe (\u2018) Use in contractions for a conversational tone. Avoid using the possessive form. capitalization Use sentence style capitalization for all headings. When referring to elements in the user interface, follow the capitalization that is used in the labels or text. Do not capitalize common terms. colon (:) Use a colon at the end of the statement that introduces a procedure, bulleted list, or table. comma (,) Use a serial comma to separate three or more items in a series, including the item before the conjunction. em dash (\u2014) Use an em dash (\u2014) to set off a parenthetical phrase with more emphasis than parentheses provide. Don\u2019t add spaces around an em dash. Don\u2019t capitalize the first word after an em dash unless the word is a proper noun. hyphenation (-) Avoid using hyphenated compound words. Use hyphens only if the meaning is unclear without them or if the only recognized form of the word includes a hyphen. quotation marks (\" \") Avoid using quotation marks unless you need to quote a message or as tring that would otherwise be confusing given its surrounding context. semicolons (;) Don't use semicolons instead of commas to separate items in a list. If you think the content should use semicolons, consider rewriting it into subtopics or an unordered bullet list. Slashes (/) and backslashes () Avoid using slashes or backslashes except when documenting paths that require either forward or backward slashes. Never use and/or in documentation.","title":"Punctuation"},{"location":"community/style-guide/#software-versions","text":"Use or later or and later to refer to multiple versions of software. For example: Firefox 3.6 or later Rust compiler (rustc) version 1.55.0 and later","title":"Software versions"},{"location":"community/style-guide/#tense","text":"Use present tense whenever possible. Use past tense only if you must describe something that has already occurred. Use future tense only if you must describe something that has not yet occurred but can be safely assumed.","title":"Tense"},{"location":"community/style-guide/#user-interface-elements","text":"In general, you should avoid writing about user interface elements. Instead, documentation should always focus on what the audience needs to do or wants to accomplish and not what is displayed on the screen. Element What to do button Use bold for the button label. Don't include \"button\" in the description. For example: Click Submit . checkbox Use checkbox, not box or check box, if you need to refer to a checkbox in the user interface. Use select and clear with checkboxes, not turn on and turn off, mark and unmark, check and uncheck, or unselect and deselect. click Use click to describe taking action on a standalone button. Do not use click on. Click and select are not interchangeable. dialog If you need to refer to a dialog box, use dialog. Don't use pop-up window, dialog box, or dialogue box. dropdown Use dropdown as an adjective, not as a noun. For example, use dropdown list .","title":"User interface elements"},{"location":"community/style-guide/#verb-usage","text":"Verb How to use it allow, enable Avoid using software as a point of view and consider rewriting to focus on the human interacting with the software. can, may, might Use the verb can when describing ability, capability, or capacity. Avoid using the verb may because it implies permission. Use the past tense might when describing the possibility or eventuality of an outcome. clear Use _ clear rather than deselect or unselect if you have to describe removing a selection from a checkbox. displays Use the transitive verb displays rather than the intransitive verb appears. Use displays with a direct object. For example, The command displays log messages. ensure Use ensure to mean to make sure or to guarantee. Remember that this is not interchangeable with assure (to make confident) and insure (to provide insurance). enter, type Use enter to instruct the user to input a value by pressing the Enter or Return key. Use type to instruct the user to type a value in a field. select Use select to describe taking action on a menu item, checkbox, or radio button. Note that click and select are not interchangeable. set up, setup Use set up \u2014two words, no hyphen\u2014when used as a verb. Don't hyphenate. Use setup \u2014one word, no hyphen\u2014when used as an adjective or as a noun. want, wish Use want instead of wish or desire when the user has a choice of actions.","title":"Verb usage"},{"location":"community/style-guide/#word-choice","text":"Word in question How to use it affect, effect Use affect as a verb and use effect as a noun. app, application Use application or applications unless there\u2019s a specific reason for using the shorthand term app or apps . back-end, front-end Using the hyphen in these terms is still more common than not using it. Both forms are acceptable, but for consistency use the hyphen. email It hasn\u2019t been e-mail for thirty-plus years. Never use emails. Don\u2019t use email as a verb. file name Use file name as two words, not filename . its, it\u2019s Use its as a possessive meaning belonging to or associated with an object or idea previously mentioned. Because it is a vague pronoun, be sure what it refers to can be easily identified. Use it\u2019s only as a contraction for it is or it has . please Avoid using please in documentation unless there\u2019s a specific reason for using it. For example, you might use please if quoting the content of a message that asks the user to do something inconvenient. prerequisite As a section title, use Before you begin instead. If you use prerequisite in the text, there\u2019s no hyphen. that, which Use that at the beginning of a clause that\u2019s necessary for the sentence to make sense. Don\u2019t put a comma before it. Don't use that when introducing a clause referring to people. Use who . Use which at the beginning of a clause that adds supporting or parenthetical information to a sentence. If you can omit the clause and the sentence still makes sense, use which , and put a comma before it. user name Use user name as two words, not username.","title":"Word choice"},{"location":"community/style-guide/#best-practices-and-common-mistakes","text":"This section highlights best practices and common mistakes to avoid.","title":"Best practices and common mistakes"},{"location":"community/style-guide/#make-every-word-count","text":"Concise sentences are easier to read, comprehend, and translate. Use simple words with precise meanings. Remove words that don\u2019t add substance. Avoid using passive to be verbs like been and being. Avoid weak or vague verbs, such as have , make , and do . When in doubt, choose the simple word or phrase over a more formal or complex one. For example: Use this Not this use utilize, make use of remove extract, take away, eliminate tell inform, let know to in order to, as a means to also in addition connect establish connectivity Whenever possible, choose words that have one clear meaning. Omit unnecessary adverbs\u2014words that describe how, when, or where. Unless they're important to the meaning of a statement, leave them out.","title":"Make every word count"},{"location":"community/style-guide/#be-consistent","text":"Use one term consistently to represent one concept. For example, if you use extrinsic, dispatchable, and transaction interchangeably or ambiguously, you\u2019ll leave the reader confused and uncertain. If terminology changes, be prepared to root out old terminology. If you use words that can be both nouns and verbs\u2014for example, words like file, post, mark, screen, record, and report\u2014use sentence structure and context to eliminate ambiguity.","title":"Be consistent"},{"location":"community/style-guide/#avoid-dangling-participles","text":"Participles are modifiers so they must have a noun to modify. A dangling participle is a participle that doesn\u2019t have a noun to modify. If you misplace or leave out the word being modified, you\u2019ll end up with a sentence that is difficult to understand, illogical, or ambiguous (though potentially amusing). Here are a few examples of sentences with dangling participles: Looking around the yard, dandelions sprouted in every corner. Walking through the kitchen, the smoke alarm was going off. Driving like a maniac, the deer was hit and killed. You can correct these sentences by bringing the participle phrase closer to the subject the phrase is intended to modify or changing the word order of the sentence to clarify who is doing what. You can also fix these types of problems by changing the tense or using the active voice. For example: Looking around the yard, I saw dandelions had sprouted in every corner. As I was walking through the kitchen, the smoke alarm was going off. Driving like a maniac, he hit a deer and killed it.","title":"Avoid dangling participles"},{"location":"community/style-guide/#dangling-prepositions","text":"In modern English, it\u2019s perfectly acceptable to end a sentence with a preposition. Don\u2019t twist a sentence into knots just to avoid using a preposition at the end. This is something you might be interested in. This is an example you should pay attention to.","title":"Dangling prepositions"},{"location":"community/style-guide/#cross-reference-formats","text":"Most cross-references should include information that clarifies what the reader can expect to be found in the referenced topic. For cross-references to topics in the Substrate documentation, use the following formats: For more information about [task or concept], see [topic-title]. For cross-references in a glossary entry to other glossary entries, use the following format: See [topic]. For cross-references to external resources, use the title of the destination instead of the URL of the destination. Avoid using links to unnamed destinations. For example, don\u2019t use links like click here or see this article .","title":"Cross-reference formats"},{"location":"community/style-guide/#writing-concept-topics","text":"Concept topics answer \u201cwhy?\u201d and \u201cwhat is\u2026?\u201d questions. Use concept topics to: Explain abstract ideas. Introduce new terminology. Offer analysis. Provide background information. The goal of a concept topic is to help the reader understand the bigger picture, the key components of a system or architecture, relationships between components. Concept topics tend to be relatively stable, requiring little, if any, ongoing maintenance. At a minimum, a concept topic includes at least one heading and one or more body paragraphs. A concept topic can also include: One or more examples. Two or more subsections, marked by subheadings. A list of related topics.","title":"Writing concept topics"},{"location":"community/style-guide/#builder-notes","text":"This repository has some conventions and peculiarities that you need to take into account when modifying it (in any way). Please read this entire section to avoid common gotchas and help make your life and the maintainers lives easier.","title":"Builder notes"},{"location":"community/style-guide/#new-pages-and-moving-files","text":"The i18n folder is used for translation but also for the rendering of the navigation elements sections . Your index.mdx file's title is not the source for this. If you are adding or renaming a page, you must add it correctly in src/components/DevNavMenu.tsx and possibly gatsby-config.js and gatsby-node.js .","title":"New pages and moving files"},{"location":"community/style-guide/#internal-link-conventions","text":"All /rustdoc/ internal links must end with .html or .html#some-ID . Reasoning can be found in #425 .","title":"Internal link conventions"},{"location":"community/style-guide/#check-rendering-images-by-clearing-cache","text":"From time to time, the development server local cache becomes corrupted. To fix this in a one liner: yarn clean && yarn dev PLEASE do this when reviewing a page before every PR - this ensures your state is what the build CI see as well.","title":"Check rendering images by clearing .cache"},{"location":"community/style-guide/#new-or-updated-yarn-packages","text":"From time to time, BREAKING changes happen in the yarn dependencies. To fix this in a one liner on main : git checkout main && git pull && yarn install && yarn clean && yarn dev Change the branch above to your working brach of choice, or start a new on for a new PR based on latest main this way. NOTE: please discard the \"private\": false, field this adds to package.json .","title":"New or updated yarn packages"},{"location":"faq-dropbox/","text":"FAQ dropbox This section provides answers to commonly-asked questions and a collection box for solutions to common problems, troubleshooting suggestions, and tips and tricks from the Parity development team and community members. For information about contributing content to the FAQ dropbox, see Contributing FAQ articles.","title":"FAQ dropbox"},{"location":"faq-dropbox/#faq-dropbox","text":"This section provides answers to commonly-asked questions and a collection box for solutions to common problems, troubleshooting suggestions, and tips and tricks from the Parity development team and community members. For information about contributing content to the FAQ dropbox, see Contributing FAQ articles.","title":"FAQ dropbox"},{"location":"how-to-guides/","text":"How-to guides Landing page or recommended path for different developer journeys.","title":"How-to guides"},{"location":"how-to-guides/#how-to-guides","text":"Landing page or recommended path for different developer journeys.","title":"How-to guides"},{"location":"how-to-guides/change-endpoint-polkadot-js/","text":"Connect to a different network To use Polkadot-JS Explorer to connect to another node: Click the network icon displayed in the top left corner of the Polkadot-JS Explorer page. Expand DEVELOPMENT at the bottom of the list of networks available. Verify the custom endpoint is set to ws://127.0.0.1:9945 . Connect to another node and port by specifying a different IP address or host name and port number for the custom endpoint. You can use a single instance of the Polkadot-JS application to connect to various nodes. Click Switch to change to the new custom endpoint. You should now see something like this example on the Network page.","title":"Change endpoint polkadot js"},{"location":"how-to-guides/change-endpoint-polkadot-js/#connect-to-a-different-network","text":"To use Polkadot-JS Explorer to connect to another node: Click the network icon displayed in the top left corner of the Polkadot-JS Explorer page. Expand DEVELOPMENT at the bottom of the list of networks available. Verify the custom endpoint is set to ws://127.0.0.1:9945 . Connect to another node and port by specifying a different IP address or host name and port number for the custom endpoint. You can use a single instance of the Polkadot-JS application to connect to various nodes. Click Switch to change to the new custom endpoint. You should now see something like this example on the Network page.","title":"Connect to a different network"},{"location":"main-docs/","text":"Substrate empowers developers source/docs/main-docs/index.md Substrate takes a modular and flexible approach to blockchain development. With every design decision, you can choose between the complexity of technical freedom and the ease of developing with predefined modules. The following diagram illustrates the nature of this flexibility. The main use cases for Substrate blockchains reflect tis sliding scale between technical freedom and development ease. At one end of the spectrum, you can deploy predefined Substrate nodes with minimal configuration and launch a blockchain with virtually no development effort. At the other end of the spectrum, you can design and implement a Substrate-based blockchain from scratch, giving you the technical freedom to innovate. Naturally, the most common use case falls between these two extremes. In the middle of the spectrum, you can use FRAME \u2014an acronym for Framework for Runtime Aggregation of Modularized Entities\u2014to create a customized Substrate runtime . With this approach, you can choose how much control you have over the blockchain logic by selecting and configuring the modules\u2014called pallets \u2014that you want to use from a library. If a pallet doesn't exist for the functionality you need, you can use FRAME to create your own custom pallet, then add it to your customized runtime. Where to go next Explore the following resources to learn more. Tell me (read related topics) FRAME and runtime development Polkadot-JS Guide me (related tutorials) Build a local blockchain Simulate a two-node network Start a private network Show me (related video content) Teach me (related how to content)","title":"Substrate empowers developers"},{"location":"main-docs/#substrate-empowers-developers","text":"source/docs/main-docs/index.md Substrate takes a modular and flexible approach to blockchain development. With every design decision, you can choose between the complexity of technical freedom and the ease of developing with predefined modules. The following diagram illustrates the nature of this flexibility. The main use cases for Substrate blockchains reflect tis sliding scale between technical freedom and development ease. At one end of the spectrum, you can deploy predefined Substrate nodes with minimal configuration and launch a blockchain with virtually no development effort. At the other end of the spectrum, you can design and implement a Substrate-based blockchain from scratch, giving you the technical freedom to innovate. Naturally, the most common use case falls between these two extremes. In the middle of the spectrum, you can use FRAME \u2014an acronym for Framework for Runtime Aggregation of Modularized Entities\u2014to create a customized Substrate runtime . With this approach, you can choose how much control you have over the blockchain logic by selecting and configuring the modules\u2014called pallets \u2014that you want to use from a library. If a pallet doesn't exist for the functionality you need, you can use FRAME to create your own custom pallet, then add it to your customized runtime.","title":"Substrate empowers developers"},{"location":"main-docs/#where-to-go-next","text":"Explore the following resources to learn more.","title":"Where to go next"},{"location":"main-docs/#tell-me-read-related-topics","text":"FRAME and runtime development Polkadot-JS","title":"Tell me (read related topics)"},{"location":"main-docs/#guide-me-related-tutorials","text":"Build a local blockchain Simulate a two-node network Start a private network","title":"Guide me (related tutorials)"},{"location":"main-docs/#show-me-related-video-content","text":"","title":"Show me (related video content)"},{"location":"main-docs/#teach-me-related-how-to-content","text":"","title":"Teach me (related how to content)"},{"location":"main-docs/blockchain-basics/","text":"Blockchain basics Blockchain software enables individual computers\u2014called nodes\u2014to communicate with each other to form a decentralized peer-to-peer (P2P) network. To ensure the security of the data on the chain and the ongoing progress of the chain, the nodes use some form of consensus to agree on the state of data in each block of data and the order in which the blocks are processed. What is a blockchain node? At a high level, a blockchain node consists of the following key components: Storage Peer-to-peer networking Consensus capabilities Data handling capabilities for external or \"extrinsic\" information A Runtime Because of the complexity involved in building these components, most blockchain projects are forked from an existing blockchain project. For example, the Bitcoin repository was forked to create: Litecoin, ZCash, Namecoin, and Bitcoin Cash. Similarly, the Ethereum repository was forked to create Quorum, POA Network, KodakCoin, and Musicoin. However, the existing blockchain platforms were not designed to allow for modification. As a result, building a new blockchain by forking has serious limitations. What is Substrate? Substrate is an open source, modular, and extensible framework for building blockchains. Substrate is designed to be flexible and allow innovators to design and build a blockchain network that meets their needs. It provides all the core components you need to build a customized blockchain node. Where to go next Explore the following resources to learn more. Tell me (read related topics) Fundamentals Guide me (related tutorials) Build a local blockchain Simulate a two-node network Start a private network Show me (related video content) Teach me (how to) If you prefer to explore code directly, you can start building in the Developer Playground and consult the API reference to get details about the Rust crates you use.","title":"Blockchain basics"},{"location":"main-docs/blockchain-basics/#blockchain-basics","text":"Blockchain software enables individual computers\u2014called nodes\u2014to communicate with each other to form a decentralized peer-to-peer (P2P) network. To ensure the security of the data on the chain and the ongoing progress of the chain, the nodes use some form of consensus to agree on the state of data in each block of data and the order in which the blocks are processed.","title":"Blockchain basics"},{"location":"main-docs/blockchain-basics/#what-is-a-blockchain-node","text":"At a high level, a blockchain node consists of the following key components: Storage Peer-to-peer networking Consensus capabilities Data handling capabilities for external or \"extrinsic\" information A Runtime Because of the complexity involved in building these components, most blockchain projects are forked from an existing blockchain project. For example, the Bitcoin repository was forked to create: Litecoin, ZCash, Namecoin, and Bitcoin Cash. Similarly, the Ethereum repository was forked to create Quorum, POA Network, KodakCoin, and Musicoin. However, the existing blockchain platforms were not designed to allow for modification. As a result, building a new blockchain by forking has serious limitations.","title":"What is a blockchain node?"},{"location":"main-docs/blockchain-basics/#what-is-substrate","text":"Substrate is an open source, modular, and extensible framework for building blockchains. Substrate is designed to be flexible and allow innovators to design and build a blockchain network that meets their needs. It provides all the core components you need to build a customized blockchain node.","title":"What is Substrate?"},{"location":"main-docs/blockchain-basics/#where-to-go-next","text":"Explore the following resources to learn more.","title":"Where to go next"},{"location":"main-docs/blockchain-basics/#tell-me-read-related-topics","text":"Fundamentals","title":"Tell me (read related topics)"},{"location":"main-docs/blockchain-basics/#guide-me-related-tutorials","text":"Build a local blockchain Simulate a two-node network Start a private network","title":"Guide me (related tutorials)"},{"location":"main-docs/blockchain-basics/#show-me-related-video-content","text":"","title":"Show me (related video content)"},{"location":"main-docs/blockchain-basics/#teach-me-how-to","text":"If you prefer to explore code directly, you can start building in the Developer Playground and consult the API reference to get details about the Rust crates you use.","title":"Teach me (how to)"},{"location":"main-docs/build/","text":"Build Introduction to languages and tools Rust basics and best practices Create custom pallets Front-end development Blockchain-specific best practices write efficient code simple or complex functions minimize database reads/writes be mindful of constraints (processing time for computation, network bandwidth, storage, memory) Substrate-specific syntax / structures (macros?) Examples of good APIs Examples of using extrinsics Examples of using storage","title":"Build"},{"location":"main-docs/build/#build","text":"Introduction to languages and tools Rust basics and best practices Create custom pallets Front-end development Blockchain-specific best practices write efficient code simple or complex functions minimize database reads/writes be mindful of constraints (processing time for computation, network bandwidth, storage, memory) Substrate-specific syntax / structures (macros?) Examples of good APIs Examples of using extrinsics Examples of using storage","title":"Build"},{"location":"main-docs/choose-a-dev-platform/","text":"Choosing a development platform for your project Cover the main tenets: Flexible (extensible, customizable, adaptable) Open source Multi-chain interoperability Future proof upgradeability Scalability Ease of development < > technical freedom and control Technical freedom < > burden of responsibility Evaluate: Is the Substrate / Polkadot vision right for your project/business model? Evaluate: Is Substrate / Polkadot the right tool for the requirements of your project/business model? At a high-level, summarize: What is possible on smart contract platforms and how that compares to developing a Substrate runtime You can build smart contracts to run on a Substrate network What Substrate offers that traditional smart contract platforms don't","title":"Choosing a development platform for your project"},{"location":"main-docs/choose-a-dev-platform/#choosing-a-development-platform-for-your-project","text":"Cover the main tenets: Flexible (extensible, customizable, adaptable) Open source Multi-chain interoperability Future proof upgradeability Scalability Ease of development < > technical freedom and control Technical freedom < > burden of responsibility Evaluate: Is the Substrate / Polkadot vision right for your project/business model? Evaluate: Is Substrate / Polkadot the right tool for the requirements of your project/business model? At a high-level, summarize: What is possible on smart contract platforms and how that compares to developing a Substrate runtime You can build smart contracts to run on a Substrate network What Substrate offers that traditional smart contract platforms don't","title":"Choosing a development platform for your project"},{"location":"main-docs/deploy/","text":"Deploy Launch a solo chain (public chain? private chain? permissioned chain?) Some of these topics might have been touched on in earlier phases, but it this section the focus is on what's relevant to deploying your customized blockchain. Validators / consensus Networking basics Finality Genesis construction Protecting the network from attacks Potentially, this bucket might cover DevOps material, maintenance, monitoring, and operations topics.","title":"Deploy"},{"location":"main-docs/deploy/#deploy","text":"Launch a solo chain (public chain? private chain? permissioned chain?) Some of these topics might have been touched on in earlier phases, but it this section the focus is on what's relevant to deploying your customized blockchain. Validators / consensus Networking basics Finality Genesis construction Protecting the network from attacks Potentially, this bucket might cover DevOps material, maintenance, monitoring, and operations topics.","title":"Deploy"},{"location":"main-docs/design/","text":"Design Smart contract platform Smart contract pallet EVM pallet Prototype using smart contracts Plan how to compose a runtime Design a pallet Storage design decisions Query and update efficiency Ecomonic models","title":"Design"},{"location":"main-docs/design/#design","text":"Smart contract platform Smart contract pallet EVM pallet Prototype using smart contracts Plan how to compose a runtime Design a pallet Storage design decisions Query and update efficiency Ecomonic models","title":"Design"},{"location":"main-docs/explore/","text":"Explore Substrate sampler Road map of resources available, where to go for what. Developer Playground Build a local blockchain Curated projects on the awesome list Where to find examples Where to find reference docs Where to find videos","title":"Explore"},{"location":"main-docs/explore/#explore","text":"Substrate sampler Road map of resources available, where to go for what. Developer Playground Build a local blockchain Curated projects on the awesome list Where to find examples Where to find reference docs Where to find videos","title":"Explore"},{"location":"main-docs/fundamentals/","text":"Fundamentals It probably needs to be a section, not a page. Substrate architecture Network architecture Private solo chain Private enterprise chain (permissioned?) Parachain Relay chain Substrate as the foundation for Polkadot, Kusama, testnets Anatomy of a node (light client, full client) Inbound request pool (extrinsic, peer-to-peer induction, Consensus (models, block authoring, selection, validation, finalization,life cycle of a message)) Economics (incentives, safety of the network, guardrails) Governance Software development (Rust, Wasm, frame and pallets, data storage, tech stack)","title":"Fundamentals"},{"location":"main-docs/fundamentals/#fundamentals","text":"It probably needs to be a section, not a page. Substrate architecture Network architecture Private solo chain Private enterprise chain (permissioned?) Parachain Relay chain Substrate as the foundation for Polkadot, Kusama, testnets Anatomy of a node (light client, full client) Inbound request pool (extrinsic, peer-to-peer induction, Consensus (models, block authoring, selection, validation, finalization,life cycle of a message)) Economics (incentives, safety of the network, guardrails) Governance Software development (Rust, Wasm, frame and pallets, data storage, tech stack)","title":"Fundamentals"},{"location":"main-docs/install/","text":"Install Rust builds Linux macOS Windows Full node Versioning and upgrades Other tools Troubleshoot common issues","title":"Install"},{"location":"main-docs/install/#install","text":"Rust builds Linux macOS Windows Full node Versioning and upgrades Other tools Troubleshoot common issues","title":"Install"},{"location":"main-docs/migrate/","text":"Migrate to Polkadot Construct Cumulus Launch Parachain PoV Limitations that apply to parachains Collators Maintain a parachain","title":"Migrate to Polkadot"},{"location":"main-docs/migrate/#migrate-to-polkadot","text":"Construct Cumulus Launch Parachain PoV Limitations that apply to parachains Collators Maintain a parachain","title":"Migrate to Polkadot"},{"location":"main-docs/monitor/","text":"Monitor Metrics and dashboards Alerting on bad behavior","title":"Monitor"},{"location":"main-docs/monitor/#monitor","text":"Metrics and dashboards Alerting on bad behavior","title":"Monitor"},{"location":"main-docs/operate/","text":"Operate Maintain the blockchain you have deployed Keeping up with Substrate metadata updates. Maintain runtime uptime","title":"Operate"},{"location":"main-docs/operate/#operate","text":"Maintain the blockchain you have deployed Keeping up with Substrate metadata updates. Maintain runtime uptime","title":"Operate"},{"location":"main-docs/retire/","text":"Retire Release your slot?","title":"Retire"},{"location":"main-docs/retire/#retire","text":"Release your slot?","title":"Retire"},{"location":"main-docs/test/","text":"Test Benchmark Unit (local) testing Debug Deploy on a testnet Validate","title":"Test"},{"location":"main-docs/test/#test","text":"Benchmark Unit (local) testing Debug Deploy on a testnet Validate","title":"Test"},{"location":"main-docs/upgrade/","text":"Upgrade Runtime upgrades Runtime migrations","title":"Upgrade"},{"location":"main-docs/upgrade/#upgrade","text":"Runtime upgrades Runtime migrations","title":"Upgrade"},{"location":"main-docs/fundamentals/","text":"Fundamentals It probably needs to be a section, not a page. Substrate architecture Network architecture Private solo chain Private enterprise chain (permissioned?) Parachain Relay chain Substrate as the foundation for Polkadot, Kusama, testnets Anatomy of a node (light client, full client) Inbound request pool (extrinsic, peer-to-peer induction, Consensus (models, block authoring, selection, validation, finalization,life cycle of a message)) Economics (incentives, safety of the network, guardrails) Governance Software development (Rust, Wasm, frame and pallets, data storage, tech stack)","title":"Fundamentals"},{"location":"main-docs/fundamentals/#fundamentals","text":"It probably needs to be a section, not a page. Substrate architecture Network architecture Private solo chain Private enterprise chain (permissioned?) Parachain Relay chain Substrate as the foundation for Polkadot, Kusama, testnets Anatomy of a node (light client, full client) Inbound request pool (extrinsic, peer-to-peer induction, Consensus (models, block authoring, selection, validation, finalization,life cycle of a message)) Economics (incentives, safety of the network, guardrails) Governance Software development (Rust, Wasm, frame and pallets, data storage, tech stack)","title":"Fundamentals"},{"location":"main-docs/fundamentals/blockchain-basics/","text":"Blockchain basics Blockchain software enables individual computers\u2014called nodes\u2014to communicate with each other to form a decentralized peer-to-peer (P2P) network. To ensure the security of the data on the chain and the ongoing progress of the chain, the nodes use some form of consensus to agree on the state of data in each block of data and the order in which the blocks are processed. What is a blockchain node? At a high level, a blockchain node consists of the following key components: Storage Peer-to-peer networking Consensus capabilities Data handling capabilities for external or \"extrinsic\" information A Runtime Because of the complexity involved in building these components, most blockchain projects are forked from an existing blockchain project. For example, the Bitcoin repository was forked to create: Litecoin, ZCash, Namecoin, and Bitcoin Cash. Similarly, the Ethereum repository was forked to create Quorum, POA Network, KodakCoin, and Musicoin. However, the existing blockchain platforms were not designed to allow for modification. As a result, building a new blockchain by forking has serious limitations. What is Substrate? Substrate is an open source, modular, and extensible framework for building blockchains. Substrate is designed to be flexible and allow innovators to design and build a blockchain network that meets their needs. It provides all the core components you need to build a customized blockchain node. Where to go next Explore the following resources to learn more. Tell me (read related topics) Fundamentals Guide me (related tutorials) Build a local blockchain Simulate a two-node network Start a private network Show me (related video content) Teach me (how to) If you prefer to explore code directly, you can start building in the Developer Playground and consult the API reference to get details about the Rust crates you use.","title":"Blockchain basics"},{"location":"main-docs/fundamentals/blockchain-basics/#blockchain-basics","text":"Blockchain software enables individual computers\u2014called nodes\u2014to communicate with each other to form a decentralized peer-to-peer (P2P) network. To ensure the security of the data on the chain and the ongoing progress of the chain, the nodes use some form of consensus to agree on the state of data in each block of data and the order in which the blocks are processed.","title":"Blockchain basics"},{"location":"main-docs/fundamentals/blockchain-basics/#what-is-a-blockchain-node","text":"At a high level, a blockchain node consists of the following key components: Storage Peer-to-peer networking Consensus capabilities Data handling capabilities for external or \"extrinsic\" information A Runtime Because of the complexity involved in building these components, most blockchain projects are forked from an existing blockchain project. For example, the Bitcoin repository was forked to create: Litecoin, ZCash, Namecoin, and Bitcoin Cash. Similarly, the Ethereum repository was forked to create Quorum, POA Network, KodakCoin, and Musicoin. However, the existing blockchain platforms were not designed to allow for modification. As a result, building a new blockchain by forking has serious limitations.","title":"What is a blockchain node?"},{"location":"main-docs/fundamentals/blockchain-basics/#what-is-substrate","text":"Substrate is an open source, modular, and extensible framework for building blockchains. Substrate is designed to be flexible and allow innovators to design and build a blockchain network that meets their needs. It provides all the core components you need to build a customized blockchain node.","title":"What is Substrate?"},{"location":"main-docs/fundamentals/blockchain-basics/#where-to-go-next","text":"Explore the following resources to learn more.","title":"Where to go next"},{"location":"main-docs/fundamentals/blockchain-basics/#tell-me-read-related-topics","text":"Fundamentals","title":"Tell me (read related topics)"},{"location":"main-docs/fundamentals/blockchain-basics/#guide-me-related-tutorials","text":"Build a local blockchain Simulate a two-node network Start a private network","title":"Guide me (related tutorials)"},{"location":"main-docs/fundamentals/blockchain-basics/#show-me-related-video-content","text":"","title":"Show me (related video content)"},{"location":"main-docs/fundamentals/blockchain-basics/#teach-me-how-to","text":"If you prefer to explore code directly, you can start building in the Developer Playground and consult the API reference to get details about the Rust crates you use.","title":"Teach me (how to)"},{"location":"main-docs/fundamentals/build-local-blockchain/","text":"","title":"Build local blockchain"},{"location":"main-docs/fundamentals/simulate-2-node-network/","text":"","title":"Simulate 2 node network"},{"location":"main-docs/fundamentals/start-a-private-network/","text":"","title":"Start a private network"},{"location":"main-docs/fundamentals/substrate-client/","text":"Substrate architecture Substrate nodes run a Substrate client application. The Substrate client application provides several important blockchain components including the following: Storage : used to persist the evolving state of a Substrate blockchain The blockchain network allows participants to reach trustless consensus about the state of storage. Substrate ships with a simple and highly efficient key-value storage mechanism . Runtime : the logic that defines how blocks are processed, including state transition logic. In Substrate, runtime code is compiled to Wasm and becomes part of the blockchain's storage state. This enables one of the defining features of a Substrate-based blockchain: forkless runtime upgrades . Substrate clients can also include a \"native runtime\" that is compiled for the same platform as the client itself (as opposed to Wasm). The component of the client that dispatches calls to the runtime is known as the executor , whose role is to select between the native code and interpreted Wasm. Although the native runtime may offer a performance advantage, the executor will select to interpret the Wasm runtime if it implements a newer version . Peer-to-peer network : the capabilities that allow the client to communicate with other network participants. Substrate uses the Rust implementation of the libp2p network stack to achieve this. Consensus : the logic that allows network participants to agree on the state of the blockchain. Substrate makes it possible to supply custom consensus engines and also ships with several consensus mechanisms that have been built on top of Web3 Foundation research . RPC (remote procedure call): the capabilities that allow blockchain users to interact with the network. Substrate provides HTTP and WebSocket RPC servers. Telemetry : client metrics that are exposed by the embedded Prometheus server.","title":"Substrate architecture"},{"location":"main-docs/fundamentals/substrate-client/#substrate-architecture","text":"Substrate nodes run a Substrate client application. The Substrate client application provides several important blockchain components including the following: Storage : used to persist the evolving state of a Substrate blockchain The blockchain network allows participants to reach trustless consensus about the state of storage. Substrate ships with a simple and highly efficient key-value storage mechanism . Runtime : the logic that defines how blocks are processed, including state transition logic. In Substrate, runtime code is compiled to Wasm and becomes part of the blockchain's storage state. This enables one of the defining features of a Substrate-based blockchain: forkless runtime upgrades . Substrate clients can also include a \"native runtime\" that is compiled for the same platform as the client itself (as opposed to Wasm). The component of the client that dispatches calls to the runtime is known as the executor , whose role is to select between the native code and interpreted Wasm. Although the native runtime may offer a performance advantage, the executor will select to interpret the Wasm runtime if it implements a newer version . Peer-to-peer network : the capabilities that allow the client to communicate with other network participants. Substrate uses the Rust implementation of the libp2p network stack to achieve this. Consensus : the logic that allows network participants to agree on the state of the blockchain. Substrate makes it possible to supply custom consensus engines and also ships with several consensus mechanisms that have been built on top of Web3 Foundation research . RPC (remote procedure call): the capabilities that allow blockchain users to interact with the network. Substrate provides HTTP and WebSocket RPC servers. Telemetry : client metrics that are exposed by the embedded Prometheus server.","title":"Substrate architecture"},{"location":"main-docs/install/","text":"Install Rust builds Linux macOS Windows Full node Versioning and upgrades Other tools Troubleshoot common issues","title":"Install"},{"location":"main-docs/install/#install","text":"Rust builds Linux macOS Windows Full node Versioning and upgrades Other tools Troubleshoot common issues","title":"Install"},{"location":"main-docs/install/rust-builds/","text":"Rust build and toolchain versions Some stuff about Rust.","title":"Rust build and toolchain versions"},{"location":"main-docs/install/rust-builds/#rust-build-and-toolchain-versions","text":"Some stuff about Rust.","title":"Rust build and toolchain versions"},{"location":"main-docs/vision/choose-a-dev-platform/","text":"Choosing a development platform for your project Cover the main tenets: Flexible (extensible, customizable, adaptable) Open source Multi-chain interoperability Future proof upgradeability Scalability Ease of development < > technical freedom and control Technical freedom < > burden of responsibility Evaluate: Is the Substrate / Polkadot vision right for your project/business model? Evaluate: Is Substrate / Polkadot the right tool for the requirements of your project/business model? At a high-level, summarize: What is possible on smart contract platforms and how that compares to developing a Substrate runtime You can build smart contracts to run on a Substrate network What Substrate offers that traditional smart contract platforms","title":"Why Substrate?"},{"location":"main-docs/vision/choose-a-dev-platform/#choosing-a-development-platform-for-your-project","text":"Cover the main tenets: Flexible (extensible, customizable, adaptable) Open source Multi-chain interoperability Future proof upgradeability Scalability Ease of development < > technical freedom and control Technical freedom < > burden of responsibility Evaluate: Is the Substrate / Polkadot vision right for your project/business model? Evaluate: Is Substrate / Polkadot the right tool for the requirements of your project/business model? At a high-level, summarize: What is possible on smart contract platforms and how that compares to developing a Substrate runtime You can build smart contracts to run on a Substrate network What Substrate offers that traditional smart contract platforms","title":"Choosing a development platform for your project"},{"location":"reference/","text":"Reference This section contains API documentation and links to reference material for tools and libraries.","title":"Reference"},{"location":"reference/#reference","text":"This section contains API documentation and links to reference material for tools and libraries.","title":"Reference"},{"location":"reference/client-lib/","text":"Client libraries There are language-specific client libraries that you can use to interact with Substrate-based blockchains. In general, these libraries expose functions that are implemented using the Substrate remote procedure call (RPC) API. JavaScript The Polkadot JS team maintains a rich set of tools for interacting with Substrate-based blockchains. Refer to the main Polkadot JS page to learn more about that suite of tools. Parity also maintains txwrapper , which is a Javascript library for offline generation of Substrate transactions. Go The Go Substrate RPC Client , AKA GSRPC, is maintained by Centrifuge . C Polkadot API DotNet is a Substrate RPC client library for .Net programmers. It is maintained by Usetech . SubstrateNetApi .NET Standard API ( nuget ) allowing full substrate integration in Unity3D for gaming development, starter template project . It is maintained by DOTMog Team . C++ Usetech also maintains Polkadot API CPP, which is a C++ library for interacting with the Substrate RPC. Rust Parity maintains substrate-subxt , which is a Rust library specifically designed for submitting extrinsics to Substrate blockchains. The the Substrate API Client is another Substrate client library for Rust that is maintained by Supercomputing Systems; its API is more general-purpose than substrate-subxt . Python py-substrate-interface is a Python library for interacting with the Substrate RPC. It supports a wide range of capabilities and powers the Polkascan multi-chain block explorer . This library is maintained by Polkascan Foundation .","title":"Client libraries"},{"location":"reference/client-lib/#client-libraries","text":"There are language-specific client libraries that you can use to interact with Substrate-based blockchains. In general, these libraries expose functions that are implemented using the Substrate remote procedure call (RPC) API.","title":"Client libraries"},{"location":"reference/client-lib/#javascript","text":"The Polkadot JS team maintains a rich set of tools for interacting with Substrate-based blockchains. Refer to the main Polkadot JS page to learn more about that suite of tools. Parity also maintains txwrapper , which is a Javascript library for offline generation of Substrate transactions.","title":"JavaScript"},{"location":"reference/client-lib/#go","text":"The Go Substrate RPC Client , AKA GSRPC, is maintained by Centrifuge .","title":"Go"},{"location":"reference/client-lib/#c","text":"Polkadot API DotNet is a Substrate RPC client library for .Net programmers. It is maintained by Usetech . SubstrateNetApi .NET Standard API ( nuget ) allowing full substrate integration in Unity3D for gaming development, starter template project . It is maintained by DOTMog Team .","title":"C"},{"location":"reference/client-lib/#c_1","text":"Usetech also maintains Polkadot API CPP, which is a C++ library for interacting with the Substrate RPC.","title":"C++"},{"location":"reference/client-lib/#rust","text":"Parity maintains substrate-subxt , which is a Rust library specifically designed for submitting extrinsics to Substrate blockchains. The the Substrate API Client is another Substrate client library for Rust that is maintained by Supercomputing Systems; its API is more general-purpose than substrate-subxt .","title":"Rust"},{"location":"reference/client-lib/#python","text":"py-substrate-interface is a Python library for interacting with the Substrate RPC. It supports a wide range of capabilities and powers the Polkascan multi-chain block explorer . This library is maintained by Polkascan Foundation .","title":"Python"},{"location":"reference/glossary/","text":"Glossary This page defines and explains many of the domain-specific terms that are common to the Substrate ecosystem. This is a helpful resource for even the most experienced Substrate developers. adaptive quorum biasing (AQB) Provides a mechanism for adjusting the passing threshold for a referendum based on voter turnout. Adaptive quorum biasing allows for more flexible governance by removing the requirement to have an arbitrary quorum for voting purposes, which create undesirable governance mechanics. Adaptive quorum biasing is implemented in the Democracy pallet . The Democracy pallet provides the interfaces for on-chain bodies such as a collective or individual token holder\u2014to call referenda with positive, negative, or neutral biases. With a positive turnout bias , the passing threshold decreases as more votes are cast, so that a higher turnout increases the likelihood of a referendum passing. With a negative turnout bias , the passing threshold increases as more votes are cast. Negative turnout bias is also sometimes called a \"default carries\" position because if there's an apathetic voting body, the referendum passes by default. A neutral turnout bias specifies a simple majority passing threshold. aggregation Used in the context of FRAME , aggregation or pallet aggregation is the process of combining analogous types from multiple runtime modules into a single type. Pallet aggregation allows each module's analogous types to be represented. Currently, there are six such data types: Call for published functions that can be called with a set of arguments. Error for messages that indicate why a function invocation ( Call ) failed. Event for pallet-emitted events that describe state changes. Log for extensible header items. Metadata for information that allows inspection of the above. Origin for the source of a function invocation ( Call ). approval voting Voting system where voters can vote for as many candidates as desired. The candidate with the highest overall number of votes wins. With approval voting, it is worth noting the following: Voting for all candidates is the same as voting for none. It is possible to vote against a single candidate by voting for all other candidates. Approval voting is used by the FRAME Elections Phragmen pallet as a governing Council on a number of Substrate-based chains. author Describes the node that is responsible for the creation of a block . Block authors are also referred to as block producers . In a proof-of-work blockchain, these nodes are called miners . authority The nodes that act as a collective to manage consensus on a blockchain network. In a proof-of-stake blockchain\u2014for example, a blockchain that us the Staking pallet from FRAME \u2014authorities are determined through a token-weighted nomination and voting system. The terms authorities and validators sometimes seem to refer the same thing. However, validators is a broader term that can include other aspects of chain maintenance such as parachain validation. In general, authorities are a (non-strict) subset of validators and many validators are authorities. authority round (Aura) Deterministic consensus protocol where block production is limited to a rotating list of authorities that take turns creating blocks. With authority round (Aura) consensus, the majority of online authorities are assumed to be honest. Learn more by reading the official wiki article for the Aura consensus algorithm. The Aura protocol is often used in combination with GRANDPA as a hybrid consensus protocol where Aura is used for block production and short-term probabilistic finality , with deterministic finality provided by GRANDPA . blind assignment of blockchain extension (BABE) A block authoring protocol similar to Aura . However, with the blind assignment of blockchain extension (BABE) protocol, authorities win slots based on a verifiable random function (VRF) as opposed to the round-robin selection method. The winning authority can select a chain and submit a new block for it. Learn more about BABE by referring to its official Web3 Foundation research document . block Describes a single element of a blockchain that cryptographically binds a set of extrinsic data\u2014the body\u2014to a header . Blocks are arranged into a tree through parent pointers. The pointer to a parent block is a hash of the parent and the tree is pruned into a list using a fork-choice rule and an optional finality mechanism. blockchain Describes a distributed network of computers that uses cryptography to allow a group of participants to trustlessly come to consensus on the state of a system as it evolves over time The computers that compose the blockchain network are called nodes . Byzantine fault tolerance (BFT) Defines the ability of a distributed computer network to remain operational if a certain proportion of its nodes or authorities are defective or behaving maliciously. Typically, a distributed network is considered byzantine fault tolerant if it can remain functional with up to one-third of nodes assumed to defective, offline, actively malicious, and acting as part of a coordinated attack. Byzantine failure The loss of a network service due to node failures that exceed the proprortion of nodes required to reach consensus. practical byzantine fault tolerance (pBFT) An early approach to Byzantine fault tolerance. pBFT systems tolerate Byzantine behavior from up to one-third of participants. The communication overhead for such systems is O(n\u00b2) , where n is the number of nodes (participants) in the system. consensus In the context of a blockchain , consensus is the process nodes use to agree on the canonical fork of a chain. Consensus is comprised of authorship , finality , and fork-choice rule . In the Substrate ecosystem, these three components are separated from one another, and the term consensus often refers specifically to authorship. In the context of a Substrate node , the term consensus engine describes the node subsystem that is responsible for consensus tasks. See also hybrid consensus . consensus algorithm An algorithm that ensures that a set of actors \u2014who don't necessarily trust each other\u2014can reach agreement about state as the result of some computation. Because most consensus algorithms assume that up to one-third of the actors or nodes can are Byzantine fault tolerant . Consensus algorithms are generately concerned with ensuring two properties: safety indicating that all honest nodes eventually agreed on the state of the chain. liveness \" indicating the ability for the chain to keep making progress. For detailed information about the consensus strategies of the Polkadot network , see the Polkadot Consensus blog series. See also hybrid consensus . cryptographic primitives A general term used to describe fundamental cryptographic concepts such as signature schemes and hashing algorithms. Cryptographic primitives are essential to many aspects of the Substrate ecosystem. For example: Hashing algorithms produce blocks of hashed data and each block uses the hash generated by the hashing algorithm to reference its parent block. Hashing is used to encode state as a trie data structure to facilitate efficient verification. Digital signature schemes are used to secure different consensus models such as authorities . Cryptographic schemes identify and authenticate the accounts used to perform transactions in the Substrate runtime. council Most often used to refer to an instance of the Collective pallet on Substrate-based networks such as Kusama or Polkadot if the Collective pallet is part of the FRAME -based runtime for the network. A council primarily serves to optimize and balance the more inclusive referendum system. database backend The means by which the state of a blockchain network is persisted between invocations of the blockchain node application. For information about how the database backend is implemented and used by Substrate-based chains, see Advanced storage . dev phrase A mnemonic phrase that is intentionally made public. All of the well-known development accounts (Alice, Bob, Charlie, Dave, Eve, and Ferdie) are generated from the same dev phrase. The dev phrase is: bottom drive obey lake curtain smoke basket hold race lonely fit walk Many tools in the Substrate ecosystem, such as subkey , allow users to implicitly specify the dev phrase by only specifying a derivation path such as //Alice . digest An extensible field of the block header that encodes information needed by several actors in a blockchain network including: Light clients for chain synchronization. Consensus engines for block verification. The runtime itself in the case of pre-runtime digests. dispatch The execution of a function with a predefined set of arguments. In the context of runtime development with FRAME , a dispatch takes pure data\u2014the type is known as Call by convention\u2014and uses that data to call a published function in a runtime module ( pallet ) with predefined arguments. The published functions take one additional parameter, known as origin , that allows the function to securely determine the provenance of its execution. equivocating A type of erroneous or malicious behavior that involves backing multiple mutually-exclusive options within the consensus mechanism. ethash A function used by some proof-of-work consensus systems, such as the Ethereum blockchain. It was developed by a team led by Tim Hughes . events A means of recording, for the benefit of the off-chain world, that some particular state transition happened. In the context of FRAME , events are a composable data types that each pallet can individually define. Events in FRAME are implemented as a set of transient storage items that are inspected immediately after a block has executed and reset during block-initialization. executor A means of executing a function call in a given runtime with a set of dependencies. There are two executor implementations present in Substrate, WebAssembly and native . The native executor uses a natively compiled runtime embedded in the node to execute calls. This is a performance optimization that up-to-date nodes can take advantage of. The WebAssembly executor uses a Wasm binary and a Wasm interpreter to execute calls. The binary is guaranteed to be up-to-date regardless of the version of the blockchain node because it is persisted in the state of the Substrate-based chain. extrinsic Data that is external to the blockchain and included in a block . In general, there are two types of extrinsics: signed or unsigned transactions. inherents inserted by block authors . existential deposit The minimum balance an account is allowed to have in the Balances pallet . Accounts cannot be created with a balance less than the existential deposit amount. If an account balance drops below this amount, the Balances pallet uses a FRAME System API to drop its references to that account. If all of the references to an account are dropped, the account can be reaped . finality The part of consensus that makes the ongoing progress of the blockchain irreversible. After a block is finalized, all of the state changes it encapsulates are irreversible without a hard fork. The consensus algorithm must guarantee that finalized blocks never need reverting. However, different consensus algorithms can define different finalization methods. In a consensus protocol that uses deterministic finality , each block is guaranteed to be the canonical block for that chain when the block is included. Deterministic finality is desirable in situations where the full chain is not available, such as in the case of light clients . GRANDPA is the deterministic finality protocol that is used by the Polkadot Network . In a consensus protocol that uses probabilistic finality , finality is expressed in terms of a probability, denoted by p , that a proposed block, denoted by B , will remain in the canonical chain. As more blocks are produced on top of B , p approaches 1. In a consensus protocol that uses instant finality , finality is guaranteed immediately upon block production. This type of non-probabilistic consensus tends to use practical byzantine fault tolerance (pBFT) and have expensive communication requirements. proof-of-finality Data that can be used to prove that a particular block is finalized. fork Indicates that there are divergent paths a blockchain might take. If two or more blocks have the same parent but different state, the blockchain cannot continue to progress until the differences are resolved . An unresolved fork would split the blockchain into two separate chains. By resolving divergent forks, you can ensure that only one canonical chain exists. Flaming Fir A Substrate-based blockchain test network that exists for developing and testing the Substrate blockchain development framework. For more information about accessing Substrate networks and flaming fir, see the Polkadot wiki . FRAME An acronym for the Framework for Runtime Aggregation of Modularized Entities that enables developers to create blockchain runtime environments from a modular set of components called pallets . Runtime developers interact with FRAME using macros such as the following: #[pallet::event] , #[pallet::error] , #[pallet::storage] , #[frame_support::pallet] The macros make it easy to define custom pallets and compose pallets to create a working runtime using the construct_runtime! macro to deploy a Substrate-based blockchain. The convention used in the Substrate codebase is to preface core FRAME modules with frame_ and the optional pallets with pallet_* . For example, the preceding macros are all defined in the frame_support module and all FRAME-based runtimes must include the frame_system module. After the frame_support::construct_runtime macro has been used to create a runtime that includes the frame_system module, optional pallets such as the Balances pallet can be used to extend the core capabilities of the runtime. full client A node that is able to synchronize a blockchain in a secure manner through execution (and thus verification) of all logic. Full clients stand in contrast to light clients . genesis configuration A mechanism for specifying the initial (genesis) state of a blockchain . Genesis configuration of Substrate-based chains is accomplished by way of a chain specification file, which makes it easy to use a single Substrate codebase to underpin multiple independently configured chains. GRANDPA A deterministic finality gadget for blockchains that is implemented in the Rust programming language. The formal specification is maintained by the Web3 Foundation Header A structure that is used to aggregate pieces of (primarily cryptographic ) information that summarize a block . This information is used by light-clients to get a minimally-secure but very efficient synchronization of the chain. hybrid consensus A blockchain consensus protocol that consists of independent or loosely coupled mechanisms for block production and finality . This allows the chain to grow as fast as probabilistic consensus protocols, such as Aura , while still maintaining the same level of security as deterministic finality consensus protocols, such as GRANDPA . In general, block production algorithms tend to be faster than finality mechanisms; separating these concerns gives Substrate developers greater control of their chain's performance. Keystore A subsystem in Substrate for managing keys for the purpose of producing new blocks. Kusama Kusama is a Substrate-based blockchain that implements a design similar to the Polkadot Network . Kusama is a \" canary \" network and is referred to as Polkadot's \"wild cousin\" . The differences between a canary network and a true test network are related to the expectations of permanence and stability; although Kusama is expected to be more stable than a true test network, like Westend , it should not be expected to be as stable as an enterprise production network like Polkadot . Unlike Westend, which is maintained by Parity Technologies , Kusama (like Polkadot) is controlled by its network participants . The level of stability offered by canary networks like Kusama is intended to encourage meaningful experimentation. libp2p A peer-to-peer networking stack that allows use of many transport mechanisms, including WebSockets (usable in a web browser). Substrate uses the Rust implementation of the libp2p networking stack. Light Client A light client is a type of blockchain node that does not store the chain state or produce ( author ) blocks. It encapsulates basic capabilities for verifying cryptographic primitives and exposes an RPC (remote procedure call) server to allow blockchain users to interact with the blockchain network. Macro Macros are features of some programming languages, including Rust , that allow developers to \"write code that writes code\". FRAME provides a number of macros that make it easy to compose a runtime . Metadata Metadata is information about a system, such as a blockchain , that makes it easier to interact with that system. Blockchain runtimes that are built with FRAME expose lots of helpful metadata . Node A node correlates to a running instance of a blockchain client; it is part of the peer-to-peer network that allows blockchain participants to interact with one another. Substrate nodes can fill a number of roles in a blockchain network. For instance, validators are the block-producing nodes that power the blockchain, while light-clients facilitate scalable interactions in resource-constrained environments like UIs or embedded devices. Nominated Proof-of-Stake (NPoS) A means of determining a set of validators (and thus authorities ) from a number of accounts willing to commit their stake to the proper (non- Byzantine ) functioning of one or more authoring /validator nodes. The Polkadot protocol describes validator selection as a constraint optimization problem to eventually give a maximally staked set of validators each with a number of supporting nominators lending their stake. Slashing and rewards are done in a pro-rata manner. Origin A FRAME primitive that identifies the source of a dispatched function call into the runtime . The FRAME System module defines three built-in origins ; pallet developers can easily define custom origins, such as those defined by the Collective pallet . Parachain A parachain is a blockchain that derives shared infrastructure and security from a \" relay chain \". You can learn more about parachains on the Polkadot Wiki . Pallet A module that can be used to extend the capabilities of a FRAME -based runtime . Pallets bundle domain-specific logic along with related runtime primitives like events , and storage items . Polkadot Network The Polkadot Network is a blockchain that serves as the central hub of a heterogeneous blockchain network. It serves the role of \" relay chain \" and supports the other chains (the \" parachains \") by providing shared infrastructure and security. The Polkadot Network is progressing through a multi-phase launch process and does not currently support parachains. Proof-of-Work A consensus mechanism that deters attacks by requiring work on the part of network participants. For instance, some proof-of-work systems require participants to use the Ethash function to calculate a hash as a proof of completed work. Relay Chain The central hub in a heterogenous (\"chain-of-chains\") network. Relay chains are blockchains that provide shared infrastructure and security to the other blockchains in the network (the \" parachains \"). In addition to providing consensus capabilities, relay chains also allow parachains to communicate and exchange digital assets without needing to trust one another. Remote Procedure Call (RPC) A mechanism for interacting with a computer program that allows developers to easily query the computer program or even invoke its logic with parameters they supply. Substrate nodes expose an RPC server on HTTP and WebSocket endpoints. JSON-RPC A standard way to call functions on a remote system by using a JSON protocol. For Substrate, this is implemented through the Parity JSON-RPC crate. Rhododendron An instant finality , Byzantine fault tolerant (BFT) consensus algorithm. One of a number of adaptions of pBFT for blockchains. Refer to its implementation on GitHub . Rococo Rococo is the Polkadot Network's parachain test network. It is a Substrate-based blockchain that is an evolving testbed for the capabilities of heterogeneous blockchain networks. Runtime The block execution logic of a blockchain, i.e. the state transition function . In Substrate, this is stored as a WebAssembly binary in the chain state . Slot A fixed, equal interval of time used by consensus engines such as Aura and BABE . In each slot, a subset of authorities is permitted (or obliged, depending on the engine) to author a block . Stake-Weighted Voting Democratic voting system that uses one-vote-per-token, rather than one-vote-per-head. State In a blockchain , the state refers to the cryptographically secure data that persists between blocks and can be used to create new blocks as part of the state transition function. In Substrate-based blockchains, state is stored in a trie , a data structure that supports the efficient creation of incremental digests. This trie is exposed to the runtime as a simple key/value map where both keys and values can be arbitrary byte arrays. State Transition Function (STF) The logic of a blockchain that determines how the state changes when a block is processed. In Substrate, this is effectively equivalent to the runtime . Storage Items FRAME primitives that provide type-safe data persistence capabilities to the runtime . Learn more about storage items in this article about runtime storage . Substrate A flexible framework for building modular, efficient, and upgradeable blockchains . Substrate is written in the Rust programming language and is maintained by Parity Technologies . Transaction A type of extrinsic that can be safely gossiped between nodes on the network thanks to efficient verification through signatures or signed extensions . Transaction Era A definable period, expressed as a range of block numbers, where a transaction may be included in a block. Transaction eras are used to protect against transaction replay attacks in the event that an account is reaped and its (replay-protecting) nonce is reset to zero. Transaction Pool A collection of transactions that are not yet included in blocks but have been determined to be valid. Tagged Transaction Pool A generic Substrate-based transaction pool implementation that allows the runtime to specify whether a given transaction is valid, how it should be prioritized, and how it relates to other transactions in the pool in terms of dependency and mutual-exclusivity. It is designed to be easily extensible and general enough to express both the UTXO and account-based transaction models. trie (Patricia Merkle Tree) An data structure that is used to represent sets of items where: a cryptographic digest of the dataset is needed; and/or it is cheap to recompute the digest with incremental changes to the dataset even when it is very large; and/or a concise proof that the dataset contains some item/pair (or lacks it) is needed. validator A semi-trusted (or untrusted but well-incentivized) actor that helps maintain a blockchain network. In Substrate, validators broadly correspond to the authorities running the consensus system. In Polkadot , validators also manage other duties such as guaranteeing data availability and validating parachain candidate blocks . WebAssembly (Wasm) An execution architecture that allows for the efficient, platform-neutral expression of deterministic, machine-executable logic. Wasm is easily compiled from the Rust programming language and is used by Substrate-based chains to provide portable runtimes that can be included as part of the chain's state . Westend Westend is a Parity -maintained, Substrate-based blockchain that serves as the test network for the Polkadot Network .","title":"Glossary"},{"location":"reference/glossary/#glossary","text":"This page defines and explains many of the domain-specific terms that are common to the Substrate ecosystem. This is a helpful resource for even the most experienced Substrate developers.","title":"Glossary"},{"location":"reference/glossary/#adaptive-quorum-biasing-aqb","text":"Provides a mechanism for adjusting the passing threshold for a referendum based on voter turnout. Adaptive quorum biasing allows for more flexible governance by removing the requirement to have an arbitrary quorum for voting purposes, which create undesirable governance mechanics. Adaptive quorum biasing is implemented in the Democracy pallet . The Democracy pallet provides the interfaces for on-chain bodies such as a collective or individual token holder\u2014to call referenda with positive, negative, or neutral biases. With a positive turnout bias , the passing threshold decreases as more votes are cast, so that a higher turnout increases the likelihood of a referendum passing. With a negative turnout bias , the passing threshold increases as more votes are cast. Negative turnout bias is also sometimes called a \"default carries\" position because if there's an apathetic voting body, the referendum passes by default. A neutral turnout bias specifies a simple majority passing threshold.","title":"adaptive quorum biasing (AQB)"},{"location":"reference/glossary/#aggregation","text":"Used in the context of FRAME , aggregation or pallet aggregation is the process of combining analogous types from multiple runtime modules into a single type. Pallet aggregation allows each module's analogous types to be represented. Currently, there are six such data types: Call for published functions that can be called with a set of arguments. Error for messages that indicate why a function invocation ( Call ) failed. Event for pallet-emitted events that describe state changes. Log for extensible header items. Metadata for information that allows inspection of the above. Origin for the source of a function invocation ( Call ).","title":"aggregation"},{"location":"reference/glossary/#approval-voting","text":"Voting system where voters can vote for as many candidates as desired. The candidate with the highest overall number of votes wins. With approval voting, it is worth noting the following: Voting for all candidates is the same as voting for none. It is possible to vote against a single candidate by voting for all other candidates. Approval voting is used by the FRAME Elections Phragmen pallet as a governing Council on a number of Substrate-based chains.","title":"approval voting"},{"location":"reference/glossary/#author","text":"Describes the node that is responsible for the creation of a block . Block authors are also referred to as block producers . In a proof-of-work blockchain, these nodes are called miners .","title":"author"},{"location":"reference/glossary/#authority","text":"The nodes that act as a collective to manage consensus on a blockchain network. In a proof-of-stake blockchain\u2014for example, a blockchain that us the Staking pallet from FRAME \u2014authorities are determined through a token-weighted nomination and voting system. The terms authorities and validators sometimes seem to refer the same thing. However, validators is a broader term that can include other aspects of chain maintenance such as parachain validation. In general, authorities are a (non-strict) subset of validators and many validators are authorities.","title":"authority"},{"location":"reference/glossary/#authority-round-aura","text":"Deterministic consensus protocol where block production is limited to a rotating list of authorities that take turns creating blocks. With authority round (Aura) consensus, the majority of online authorities are assumed to be honest. Learn more by reading the official wiki article for the Aura consensus algorithm. The Aura protocol is often used in combination with GRANDPA as a hybrid consensus protocol where Aura is used for block production and short-term probabilistic finality , with deterministic finality provided by GRANDPA .","title":"authority round (Aura)"},{"location":"reference/glossary/#blind-assignment-of-blockchain-extension-babe","text":"A block authoring protocol similar to Aura . However, with the blind assignment of blockchain extension (BABE) protocol, authorities win slots based on a verifiable random function (VRF) as opposed to the round-robin selection method. The winning authority can select a chain and submit a new block for it. Learn more about BABE by referring to its official Web3 Foundation research document .","title":"blind assignment of blockchain extension (BABE)"},{"location":"reference/glossary/#block","text":"Describes a single element of a blockchain that cryptographically binds a set of extrinsic data\u2014the body\u2014to a header . Blocks are arranged into a tree through parent pointers. The pointer to a parent block is a hash of the parent and the tree is pruned into a list using a fork-choice rule and an optional finality mechanism.","title":"block"},{"location":"reference/glossary/#blockchain","text":"Describes a distributed network of computers that uses cryptography to allow a group of participants to trustlessly come to consensus on the state of a system as it evolves over time The computers that compose the blockchain network are called nodes .","title":"blockchain"},{"location":"reference/glossary/#byzantine-fault-tolerance-bft","text":"Defines the ability of a distributed computer network to remain operational if a certain proportion of its nodes or authorities are defective or behaving maliciously. Typically, a distributed network is considered byzantine fault tolerant if it can remain functional with up to one-third of nodes assumed to defective, offline, actively malicious, and acting as part of a coordinated attack.","title":"Byzantine fault tolerance (BFT)"},{"location":"reference/glossary/#byzantine-failure","text":"The loss of a network service due to node failures that exceed the proprortion of nodes required to reach consensus.","title":"Byzantine failure"},{"location":"reference/glossary/#practical-byzantine-fault-tolerance-pbft","text":"An early approach to Byzantine fault tolerance. pBFT systems tolerate Byzantine behavior from up to one-third of participants. The communication overhead for such systems is O(n\u00b2) , where n is the number of nodes (participants) in the system.","title":"practical byzantine fault tolerance (pBFT)"},{"location":"reference/glossary/#consensus","text":"In the context of a blockchain , consensus is the process nodes use to agree on the canonical fork of a chain. Consensus is comprised of authorship , finality , and fork-choice rule . In the Substrate ecosystem, these three components are separated from one another, and the term consensus often refers specifically to authorship. In the context of a Substrate node , the term consensus engine describes the node subsystem that is responsible for consensus tasks. See also hybrid consensus .","title":"consensus"},{"location":"reference/glossary/#consensus-algorithm","text":"An algorithm that ensures that a set of actors \u2014who don't necessarily trust each other\u2014can reach agreement about state as the result of some computation. Because most consensus algorithms assume that up to one-third of the actors or nodes can are Byzantine fault tolerant . Consensus algorithms are generately concerned with ensuring two properties: safety indicating that all honest nodes eventually agreed on the state of the chain. liveness \" indicating the ability for the chain to keep making progress. For detailed information about the consensus strategies of the Polkadot network , see the Polkadot Consensus blog series. See also hybrid consensus .","title":"consensus algorithm"},{"location":"reference/glossary/#cryptographic-primitives","text":"A general term used to describe fundamental cryptographic concepts such as signature schemes and hashing algorithms. Cryptographic primitives are essential to many aspects of the Substrate ecosystem. For example: Hashing algorithms produce blocks of hashed data and each block uses the hash generated by the hashing algorithm to reference its parent block. Hashing is used to encode state as a trie data structure to facilitate efficient verification. Digital signature schemes are used to secure different consensus models such as authorities . Cryptographic schemes identify and authenticate the accounts used to perform transactions in the Substrate runtime.","title":"cryptographic primitives"},{"location":"reference/glossary/#council","text":"Most often used to refer to an instance of the Collective pallet on Substrate-based networks such as Kusama or Polkadot if the Collective pallet is part of the FRAME -based runtime for the network. A council primarily serves to optimize and balance the more inclusive referendum system.","title":"council"},{"location":"reference/glossary/#database-backend","text":"The means by which the state of a blockchain network is persisted between invocations of the blockchain node application. For information about how the database backend is implemented and used by Substrate-based chains, see Advanced storage .","title":"database backend"},{"location":"reference/glossary/#dev-phrase","text":"A mnemonic phrase that is intentionally made public. All of the well-known development accounts (Alice, Bob, Charlie, Dave, Eve, and Ferdie) are generated from the same dev phrase. The dev phrase is: bottom drive obey lake curtain smoke basket hold race lonely fit walk Many tools in the Substrate ecosystem, such as subkey , allow users to implicitly specify the dev phrase by only specifying a derivation path such as //Alice .","title":"dev phrase"},{"location":"reference/glossary/#digest","text":"An extensible field of the block header that encodes information needed by several actors in a blockchain network including: Light clients for chain synchronization. Consensus engines for block verification. The runtime itself in the case of pre-runtime digests.","title":"digest"},{"location":"reference/glossary/#dispatch","text":"The execution of a function with a predefined set of arguments. In the context of runtime development with FRAME , a dispatch takes pure data\u2014the type is known as Call by convention\u2014and uses that data to call a published function in a runtime module ( pallet ) with predefined arguments. The published functions take one additional parameter, known as origin , that allows the function to securely determine the provenance of its execution.","title":"dispatch"},{"location":"reference/glossary/#equivocating","text":"A type of erroneous or malicious behavior that involves backing multiple mutually-exclusive options within the consensus mechanism.","title":"equivocating"},{"location":"reference/glossary/#ethash","text":"A function used by some proof-of-work consensus systems, such as the Ethereum blockchain. It was developed by a team led by Tim Hughes .","title":"ethash"},{"location":"reference/glossary/#events","text":"A means of recording, for the benefit of the off-chain world, that some particular state transition happened. In the context of FRAME , events are a composable data types that each pallet can individually define. Events in FRAME are implemented as a set of transient storage items that are inspected immediately after a block has executed and reset during block-initialization.","title":"events"},{"location":"reference/glossary/#executor","text":"A means of executing a function call in a given runtime with a set of dependencies. There are two executor implementations present in Substrate, WebAssembly and native . The native executor uses a natively compiled runtime embedded in the node to execute calls. This is a performance optimization that up-to-date nodes can take advantage of. The WebAssembly executor uses a Wasm binary and a Wasm interpreter to execute calls. The binary is guaranteed to be up-to-date regardless of the version of the blockchain node because it is persisted in the state of the Substrate-based chain.","title":"executor"},{"location":"reference/glossary/#extrinsic","text":"Data that is external to the blockchain and included in a block . In general, there are two types of extrinsics: signed or unsigned transactions. inherents inserted by block authors .","title":"extrinsic"},{"location":"reference/glossary/#existential-deposit","text":"The minimum balance an account is allowed to have in the Balances pallet . Accounts cannot be created with a balance less than the existential deposit amount. If an account balance drops below this amount, the Balances pallet uses a FRAME System API to drop its references to that account. If all of the references to an account are dropped, the account can be reaped .","title":"existential deposit"},{"location":"reference/glossary/#finality","text":"The part of consensus that makes the ongoing progress of the blockchain irreversible. After a block is finalized, all of the state changes it encapsulates are irreversible without a hard fork. The consensus algorithm must guarantee that finalized blocks never need reverting. However, different consensus algorithms can define different finalization methods. In a consensus protocol that uses deterministic finality , each block is guaranteed to be the canonical block for that chain when the block is included. Deterministic finality is desirable in situations where the full chain is not available, such as in the case of light clients . GRANDPA is the deterministic finality protocol that is used by the Polkadot Network . In a consensus protocol that uses probabilistic finality , finality is expressed in terms of a probability, denoted by p , that a proposed block, denoted by B , will remain in the canonical chain. As more blocks are produced on top of B , p approaches 1. In a consensus protocol that uses instant finality , finality is guaranteed immediately upon block production. This type of non-probabilistic consensus tends to use practical byzantine fault tolerance (pBFT) and have expensive communication requirements.","title":"finality"},{"location":"reference/glossary/#proof-of-finality","text":"Data that can be used to prove that a particular block is finalized.","title":"proof-of-finality"},{"location":"reference/glossary/#fork","text":"Indicates that there are divergent paths a blockchain might take. If two or more blocks have the same parent but different state, the blockchain cannot continue to progress until the differences are resolved . An unresolved fork would split the blockchain into two separate chains. By resolving divergent forks, you can ensure that only one canonical chain exists.","title":"fork"},{"location":"reference/glossary/#flaming-fir","text":"A Substrate-based blockchain test network that exists for developing and testing the Substrate blockchain development framework. For more information about accessing Substrate networks and flaming fir, see the Polkadot wiki .","title":"Flaming Fir"},{"location":"reference/glossary/#frame","text":"An acronym for the Framework for Runtime Aggregation of Modularized Entities that enables developers to create blockchain runtime environments from a modular set of components called pallets . Runtime developers interact with FRAME using macros such as the following: #[pallet::event] , #[pallet::error] , #[pallet::storage] , #[frame_support::pallet] The macros make it easy to define custom pallets and compose pallets to create a working runtime using the construct_runtime! macro to deploy a Substrate-based blockchain. The convention used in the Substrate codebase is to preface core FRAME modules with frame_ and the optional pallets with pallet_* . For example, the preceding macros are all defined in the frame_support module and all FRAME-based runtimes must include the frame_system module. After the frame_support::construct_runtime macro has been used to create a runtime that includes the frame_system module, optional pallets such as the Balances pallet can be used to extend the core capabilities of the runtime.","title":"FRAME"},{"location":"reference/glossary/#full-client","text":"A node that is able to synchronize a blockchain in a secure manner through execution (and thus verification) of all logic. Full clients stand in contrast to light clients .","title":"full client"},{"location":"reference/glossary/#genesis-configuration","text":"A mechanism for specifying the initial (genesis) state of a blockchain . Genesis configuration of Substrate-based chains is accomplished by way of a chain specification file, which makes it easy to use a single Substrate codebase to underpin multiple independently configured chains.","title":"genesis configuration"},{"location":"reference/glossary/#grandpa","text":"A deterministic finality gadget for blockchains that is implemented in the Rust programming language. The formal specification is maintained by the Web3 Foundation","title":"GRANDPA"},{"location":"reference/glossary/#header","text":"A structure that is used to aggregate pieces of (primarily cryptographic ) information that summarize a block . This information is used by light-clients to get a minimally-secure but very efficient synchronization of the chain.","title":"Header"},{"location":"reference/glossary/#hybrid-consensus","text":"A blockchain consensus protocol that consists of independent or loosely coupled mechanisms for block production and finality . This allows the chain to grow as fast as probabilistic consensus protocols, such as Aura , while still maintaining the same level of security as deterministic finality consensus protocols, such as GRANDPA . In general, block production algorithms tend to be faster than finality mechanisms; separating these concerns gives Substrate developers greater control of their chain's performance.","title":"hybrid consensus"},{"location":"reference/glossary/#keystore","text":"A subsystem in Substrate for managing keys for the purpose of producing new blocks.","title":"Keystore"},{"location":"reference/glossary/#kusama","text":"Kusama is a Substrate-based blockchain that implements a design similar to the Polkadot Network . Kusama is a \" canary \" network and is referred to as Polkadot's \"wild cousin\" . The differences between a canary network and a true test network are related to the expectations of permanence and stability; although Kusama is expected to be more stable than a true test network, like Westend , it should not be expected to be as stable as an enterprise production network like Polkadot . Unlike Westend, which is maintained by Parity Technologies , Kusama (like Polkadot) is controlled by its network participants . The level of stability offered by canary networks like Kusama is intended to encourage meaningful experimentation.","title":"Kusama"},{"location":"reference/glossary/#libp2p","text":"A peer-to-peer networking stack that allows use of many transport mechanisms, including WebSockets (usable in a web browser). Substrate uses the Rust implementation of the libp2p networking stack.","title":"libp2p"},{"location":"reference/glossary/#light-client","text":"A light client is a type of blockchain node that does not store the chain state or produce ( author ) blocks. It encapsulates basic capabilities for verifying cryptographic primitives and exposes an RPC (remote procedure call) server to allow blockchain users to interact with the blockchain network.","title":"Light Client"},{"location":"reference/glossary/#macro","text":"Macros are features of some programming languages, including Rust , that allow developers to \"write code that writes code\". FRAME provides a number of macros that make it easy to compose a runtime .","title":"Macro"},{"location":"reference/glossary/#metadata","text":"Metadata is information about a system, such as a blockchain , that makes it easier to interact with that system. Blockchain runtimes that are built with FRAME expose lots of helpful metadata .","title":"Metadata"},{"location":"reference/glossary/#node","text":"A node correlates to a running instance of a blockchain client; it is part of the peer-to-peer network that allows blockchain participants to interact with one another. Substrate nodes can fill a number of roles in a blockchain network. For instance, validators are the block-producing nodes that power the blockchain, while light-clients facilitate scalable interactions in resource-constrained environments like UIs or embedded devices.","title":"Node"},{"location":"reference/glossary/#nominated-proof-of-stake-npos","text":"A means of determining a set of validators (and thus authorities ) from a number of accounts willing to commit their stake to the proper (non- Byzantine ) functioning of one or more authoring /validator nodes. The Polkadot protocol describes validator selection as a constraint optimization problem to eventually give a maximally staked set of validators each with a number of supporting nominators lending their stake. Slashing and rewards are done in a pro-rata manner.","title":"Nominated Proof-of-Stake (NPoS)"},{"location":"reference/glossary/#origin","text":"A FRAME primitive that identifies the source of a dispatched function call into the runtime . The FRAME System module defines three built-in origins ; pallet developers can easily define custom origins, such as those defined by the Collective pallet .","title":"Origin"},{"location":"reference/glossary/#parachain","text":"A parachain is a blockchain that derives shared infrastructure and security from a \" relay chain \". You can learn more about parachains on the Polkadot Wiki .","title":"Parachain"},{"location":"reference/glossary/#pallet","text":"A module that can be used to extend the capabilities of a FRAME -based runtime . Pallets bundle domain-specific logic along with related runtime primitives like events , and storage items .","title":"Pallet"},{"location":"reference/glossary/#polkadot-network","text":"The Polkadot Network is a blockchain that serves as the central hub of a heterogeneous blockchain network. It serves the role of \" relay chain \" and supports the other chains (the \" parachains \") by providing shared infrastructure and security. The Polkadot Network is progressing through a multi-phase launch process and does not currently support parachains.","title":"Polkadot Network"},{"location":"reference/glossary/#proof-of-work","text":"A consensus mechanism that deters attacks by requiring work on the part of network participants. For instance, some proof-of-work systems require participants to use the Ethash function to calculate a hash as a proof of completed work.","title":"Proof-of-Work"},{"location":"reference/glossary/#relay-chain","text":"The central hub in a heterogenous (\"chain-of-chains\") network. Relay chains are blockchains that provide shared infrastructure and security to the other blockchains in the network (the \" parachains \"). In addition to providing consensus capabilities, relay chains also allow parachains to communicate and exchange digital assets without needing to trust one another.","title":"Relay Chain"},{"location":"reference/glossary/#remote-procedure-call-rpc","text":"A mechanism for interacting with a computer program that allows developers to easily query the computer program or even invoke its logic with parameters they supply. Substrate nodes expose an RPC server on HTTP and WebSocket endpoints.","title":"Remote Procedure Call (RPC)"},{"location":"reference/glossary/#json-rpc","text":"A standard way to call functions on a remote system by using a JSON protocol. For Substrate, this is implemented through the Parity JSON-RPC crate.","title":"JSON-RPC"},{"location":"reference/glossary/#rhododendron","text":"An instant finality , Byzantine fault tolerant (BFT) consensus algorithm. One of a number of adaptions of pBFT for blockchains. Refer to its implementation on GitHub .","title":"Rhododendron"},{"location":"reference/glossary/#rococo","text":"Rococo is the Polkadot Network's parachain test network. It is a Substrate-based blockchain that is an evolving testbed for the capabilities of heterogeneous blockchain networks.","title":"Rococo"},{"location":"reference/glossary/#runtime","text":"The block execution logic of a blockchain, i.e. the state transition function . In Substrate, this is stored as a WebAssembly binary in the chain state .","title":"Runtime"},{"location":"reference/glossary/#slot","text":"A fixed, equal interval of time used by consensus engines such as Aura and BABE . In each slot, a subset of authorities is permitted (or obliged, depending on the engine) to author a block .","title":"Slot"},{"location":"reference/glossary/#stake-weighted-voting","text":"Democratic voting system that uses one-vote-per-token, rather than one-vote-per-head.","title":"Stake-Weighted Voting"},{"location":"reference/glossary/#state","text":"In a blockchain , the state refers to the cryptographically secure data that persists between blocks and can be used to create new blocks as part of the state transition function. In Substrate-based blockchains, state is stored in a trie , a data structure that supports the efficient creation of incremental digests. This trie is exposed to the runtime as a simple key/value map where both keys and values can be arbitrary byte arrays.","title":"State"},{"location":"reference/glossary/#state-transition-function-stf","text":"The logic of a blockchain that determines how the state changes when a block is processed. In Substrate, this is effectively equivalent to the runtime .","title":"State Transition Function (STF)"},{"location":"reference/glossary/#storage-items","text":"FRAME primitives that provide type-safe data persistence capabilities to the runtime . Learn more about storage items in this article about runtime storage .","title":"Storage Items"},{"location":"reference/glossary/#substrate","text":"A flexible framework for building modular, efficient, and upgradeable blockchains . Substrate is written in the Rust programming language and is maintained by Parity Technologies .","title":"Substrate"},{"location":"reference/glossary/#transaction","text":"A type of extrinsic that can be safely gossiped between nodes on the network thanks to efficient verification through signatures or signed extensions .","title":"Transaction"},{"location":"reference/glossary/#transaction-era","text":"A definable period, expressed as a range of block numbers, where a transaction may be included in a block. Transaction eras are used to protect against transaction replay attacks in the event that an account is reaped and its (replay-protecting) nonce is reset to zero.","title":"Transaction Era"},{"location":"reference/glossary/#transaction-pool","text":"A collection of transactions that are not yet included in blocks but have been determined to be valid.","title":"Transaction Pool"},{"location":"reference/glossary/#tagged-transaction-pool","text":"A generic Substrate-based transaction pool implementation that allows the runtime to specify whether a given transaction is valid, how it should be prioritized, and how it relates to other transactions in the pool in terms of dependency and mutual-exclusivity. It is designed to be easily extensible and general enough to express both the UTXO and account-based transaction models.","title":"Tagged Transaction Pool"},{"location":"reference/glossary/#trie-patricia-merkle-tree","text":"An data structure that is used to represent sets of items where: a cryptographic digest of the dataset is needed; and/or it is cheap to recompute the digest with incremental changes to the dataset even when it is very large; and/or a concise proof that the dataset contains some item/pair (or lacks it) is needed.","title":"trie (Patricia Merkle Tree)"},{"location":"reference/glossary/#validator","text":"A semi-trusted (or untrusted but well-incentivized) actor that helps maintain a blockchain network. In Substrate, validators broadly correspond to the authorities running the consensus system. In Polkadot , validators also manage other duties such as guaranteeing data availability and validating parachain candidate blocks .","title":"validator"},{"location":"reference/glossary/#webassembly-wasm","text":"An execution architecture that allows for the efficient, platform-neutral expression of deterministic, machine-executable logic. Wasm is easily compiled from the Rust programming language and is used by Substrate-based chains to provide portable runtimes that can be included as part of the chain's state .","title":"WebAssembly (Wasm)"},{"location":"reference/glossary/#westend","text":"Westend is a Parity -maintained, Substrate-based blockchain that serves as the test network for the Polkadot Network .","title":"Westend"},{"location":"reference/polkadot-js/","text":"Polkadot-JS reference The Polkadot-JS project is a collection of tools, interfaces, and libraries that can be used with any Substrate-based blockchain. Polkadot-JS API `} text={ The API provides application developers the ability to query a node and interact with any Substrate-based blockchain using Javascript. } linkText={ Go to Documentation } link={ https://polkadot.js.org/docs/api`} /> `} text={ The Polkadot-JS API is a library of interfaces for communicating with Polkadot and Substrate nodes. } linkText={ GitHub } link={ https://github.com/polkadot-js/api`} /> Getting started Follow the Getting Started guide to learn how to install and start using the Polkadot-JS API right away. Polkadot-JS Apps `} text={ The Polkadot-JS Apps is a flexible UI for interacting with a Polkadot or Substrate based node.. } linkText={ Go to Documentation } link={ https://polkadot.js.org/apps`} /> `} text={ This is pre-built user-facing application, allowing access to all features available on Substrate chains. } linkText={ GitHub } link={ https://github.com/polkadot-js/apps`} /> Connecting to local node To connect the Polkadot-JS Apps to your local node, you must go into Settings and change the \"endpoint to connect to\" to Local Node (127.0.0.1:9944) . gray } title={ Note } text={ If you are connected to the Polkadot-JS Apps over a secure HTTPS connection, you will need to use a browser which also supports bridging to an insecure WebSocket endpoint. For example, Google Chrome supports this, but Mozilla Firefox does not. } /> Polkadot-JS extension The Polkadot-JS Extension is a simple proof-of-concept for managing accounts in a browser extension and allowing the signing of extrinsics using these accounts. It also provides a simple interface for interacting with extension-compliant dApps. Different ways to use the extension: On Chrome On Firefox Fork on GitHub Next steps Examples Clone the Substrate Front End Template to start building a custom ReactJS app for your blockchain using Polkadot-JS API. Complete part II of the Kitties tutorial to use PolkadotJS API in action References Visit the reference docs for the Polkadot-JS API Visit the reference docs for the Polkadot-JS Common Utilities","title":"Polkadot-JS"},{"location":"reference/polkadot-js/#polkadot-js-reference","text":"The Polkadot-JS project is a collection of tools, interfaces, and libraries that can be used with any Substrate-based blockchain.","title":"Polkadot-JS reference"},{"location":"reference/polkadot-js/#polkadot-js-api","text":"`} text={ The API provides application developers the ability to query a node and interact with any Substrate-based blockchain using Javascript. } linkText={ Go to Documentation } link={ https://polkadot.js.org/docs/api`} /> `} text={ The Polkadot-JS API is a library of interfaces for communicating with Polkadot and Substrate nodes. } linkText={ GitHub } link={ https://github.com/polkadot-js/api`} />","title":"Polkadot-JS API"},{"location":"reference/polkadot-js/#getting-started","text":"Follow the Getting Started guide to learn how to install and start using the Polkadot-JS API right away.","title":"Getting started"},{"location":"reference/polkadot-js/#polkadot-js-apps","text":"`} text={ The Polkadot-JS Apps is a flexible UI for interacting with a Polkadot or Substrate based node.. } linkText={ Go to Documentation } link={ https://polkadot.js.org/apps`} /> `} text={ This is pre-built user-facing application, allowing access to all features available on Substrate chains. } linkText={ GitHub } link={ https://github.com/polkadot-js/apps`} />","title":"Polkadot-JS Apps"},{"location":"reference/polkadot-js/#connecting-to-local-node","text":"To connect the Polkadot-JS Apps to your local node, you must go into Settings and change the \"endpoint to connect to\" to Local Node (127.0.0.1:9944) . gray } title={ Note } text={ If you are connected to the Polkadot-JS Apps over a secure HTTPS connection, you will need to use a browser which also supports bridging to an insecure WebSocket endpoint. For example, Google Chrome supports this, but Mozilla Firefox does not. } />","title":"Connecting to local node"},{"location":"reference/polkadot-js/#polkadot-js-extension","text":"The Polkadot-JS Extension is a simple proof-of-concept for managing accounts in a browser extension and allowing the signing of extrinsics using these accounts. It also provides a simple interface for interacting with extension-compliant dApps. Different ways to use the extension: On Chrome On Firefox Fork on GitHub","title":"Polkadot-JS extension"},{"location":"reference/polkadot-js/#next-steps","text":"","title":"Next steps"},{"location":"reference/polkadot-js/#examples","text":"Clone the Substrate Front End Template to start building a custom ReactJS app for your blockchain using Polkadot-JS API. Complete part II of the Kitties tutorial to use PolkadotJS API in action","title":"Examples"},{"location":"reference/polkadot-js/#references","text":"Visit the reference docs for the Polkadot-JS API Visit the reference docs for the Polkadot-JS Common Utilities","title":"References"},{"location":"tutorials/","text":"Tutorials Landing page or recommended path for different developer journeys.","title":"Tutorials"},{"location":"tutorials/#tutorials","text":"Landing page or recommended path for different developer journeys.","title":"Tutorials"},{"location":"tutorials/build-local-blockchain/","text":"Build a local blockchain As you learned in Blockchain basics , a blockchain consists of decentralized computers\u2014called nodes\u2014to form a network. Substrate provides a flexible, open, and extensible development environment that allows you to design and build fully-customized blockchain nodes to suit your application or business model needs. Get started The first step in becoming a blockchain developer is to learn how to compile and launch a single local blockchain node. In this tutorial, you build and start a single node blockchain using a node template. The Substrate node template provides a working single-node blockchain that you can run locally in your development environment. The node template includes several predefined components\u2014such as user accounts and account balances\u2014so that you can experiment with performing common tasks. Without making any changes to the template, you can run a functional node that produces blocks and allows transactions. After you start the local blockchain node, this tutorial illustrates how you can use a Substrate front-end template to view information about blockchain activity and submit a transaction. Who is this tutorial for? This tutorial provides a basic introduction to Substrate and prepares a minimal working development environment that you can use to explore further in additional tutorials. It is intended for anyone interested in learning about Substrate and blockchain development. The tutorial assumes you have no prior experience or knowledge of Substrate. You don't need any programming or blockchain experience to complete this tutorial. This is just the first step, but hopefully, it inspires you to continue your journey. How much time do you need to complete this tutorial? This tutorial requires compiling Rust code and takes approximately one to two hours to complete. Before you begin For this tutorial, you download and use working code. Before you begin, verify the following: You have good internet connection and access to a shell terminal on your local computer. You are generally familiar with software development and use command-line interfaces. You are generally familiar with blockchains and smart contract platforms. You want to learn about the bleeding edge of blockchain development. By completing this tutorial, you will accomplish the following objectives: Tutorial objectives By completing this tutorial, you will accomplish the following objectives: Set up a Substrate development environment on your computer. Install the node template to start a Substrate-based blockchain. Install a front-end template to interact with the local blockchain node. Use the front-end template to submit a transaction and view the result. Install required packages Substrate development is easiest on UNIX-based operating systems like macOS or Linux. If you are using Microsoft Windows, refer to the Windows installation page . To install required packages on macOS or Linux: Open a terminal shell on your computer. Locate your operating system in the following table and run the appropriate commands for your development environment. OS Installation commands Ubuntu or Debian sudo apt update && sudo apt install -y git clang curl libssl-dev llvm libudev-dev Arch Linux pacman -Syu --needed --noconfirm curl git clang Fedora sudo dnf update sudo dnf install clang curl git openssl-devel OpenSUSE sudo zypper install clang curl git openssl-devel llvm-devel libudev-devel macOS brew update && brew install openssl Windows Refer to this installation guide . If you are using macOS and do not have Homebrew installed, run the following command to install Homebrew: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" After installing Homebrew, run brew install openssl . Install Rust and the Rust toolchain To install and configure Rust manually: Install rustup by running the following command: curl https://sh.rustup.rs -sSf | sh Configure your current shell to reload your PATH environment variable so that it includes the Cargo bin directory by running the following command: source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version by running the following commands: rustup default stable rustup update Add the nightly release and the nightly WebAssembly ( wasm ) targets by running the following commands: rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly Verify your installation by running the following commands: rustc --version rustup show The previous steps walked you through the installation and configuration of Rust and the Rust toolchain so that you could see the full process for yourself. It is also possible to automate the steps using a script. If you want to try installing and configuring Rust using a script, see the [`getsubstrate`](https://getsubstrate.io) automation script. Set up a development environment After you install the required packages and the Rust compiler and toolchain, you are ready to set up a development environment on your local computer. You could build a development environment manually using the tools of your choice, but the Substrate Developer Hub has templates to get you started. After you set up the development environment, you can use it in subsequent tutorials as you learn more about building on Substrate. Prepare a Substrate node The Substrate node template provides a working development environment so that you can start building on Substrate right away. To compile the Substrate node template: Clone the node template repository using the version latest branch by running the following command: git clone -b latest --depth 1 https://github.com/substrate-developer-hub/substrate-node-template Change to the root of the node template directory by running the following command: cd substrate-node-template Compile the node template by running the following command: cargo build --release You should always use the --release flag to build optimized artifacts. Install the front-end template The front-end template uses ReactJS to render a web browser interface that enables you to interact with the Substrate-based blockchain node. You can use this Front-end template as a starting point for creating user interfaces for your own projects in future. The front-end template requires Yarn and Node.js . If you don't have these tools, install them first. To install the front-end template: Check whether node is installed on your local computer by running the following command: node --version If the command doesn\u2019t return a version number, download and install node by following the instructions for the operating system you use on the Node.js website. The node version should be at least v14 to run the front-end template. Check whether yarn is installed on your local computer by running the following command: yarn --version The yarn version should be at least v3 to run the front-end template. If the command doesn\u2019t return a version number, download and install yarn by running the following command: npm install -g yarn Clone the front-end template repository by running the following command: git clone -b latest --depth 1 https://github.com/substrate-developer-hub/substrate-front-end-template Change to the root of the front-end template directory by running the following command: cd substrate-front-end-template Install the dependencies for the front-end template by running the following command: yarn install Start the local node After your node compiles, you are ready to start exploring what it does using the front-end template. To start the local Substrate node: Open a terminal shell. Change to the root directory where you compiled the Substrate node template. Start the node in development mode by running the following command: ./target/release/node-template --dev --tmp The node-template command-line options specify how you want the running node to operate. In this case, the options specify the following: The --dev option specifies that the node is run as a developer node chain specification. The --tmp option specifies that the node will delete all active data\u2014such as keys, blockchain database, and networking information when you stop the node by pressing Control-c. You can use --tmp option to ensure you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2021-03-16 10:56:51 Running in --dev mode, RPC CORS has been disabled. 2021-03-16 10:56:51 Substrate Node 2021-03-16 10:56:51 \u270c\ufe0f version 3.0.0-8370ddd-x86_64-linux-gnu 2021-03-16 10:56:51 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-16 10:56:51 \ud83d\udccb Chain specification: Development 2021-03-16 10:56:51 \ud83c\udff7 Node name: few-size-5380 2021-03-16 10:56:51 \ud83d\udc64 Role: AUTHORITY 2021-03-16 10:56:51 \ud83d\udcbe Database: RocksDb at /tmp/substrateP1jD7H/chains/dev/db 2021-03-16 10:56:51 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-16 10:56:51 \ud83d\udd28 Initializing Genesis block/state (state: 0x17df\u202604a0, header-hash: 0xc43b\u2026ed16) 2021-03-16 10:56:51 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-16 10:56:51 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-16 10:56:51 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-16 10:56:51 \ud83c\udff7 Local node identity is: 12D3KooWQdU84EJCqDr4aqfhb7dxXU2fzd6i2Rn1XdNtsiM5jvEC 2021-03-16 10:56:51 \ud83d\udce6 Highest known block at #0 ... ... ... 2021-03-16 10:56:56 \ud83d\udca4 Idle (0 peers), best: #2 (0x05bd\u2026de3f), finalized #0 (0xc43b\u2026ed16), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe. We'll look into the details of what's reported in the log output in a later tutorial. For now, it's only important to know that your node is running and producing blocks. Keep the terminal that displays the node output open to continue. Start the front-end template The Substrate front-end template consists of user interface components to enable you to interact with the Substrate node and perform a few common tasks. To use the front-end template: Open a new terminal shell on your computer, change to the root directory where you installed the front-end template. Start the Front-end template by running the following command: yarn start Open http://localhost:8000 in a browser to view the front-end template. The top section has an Account selection list for selecting the account to work with when you want to perform on-chain operations. The top section of the template also displays information about the chain to which you're connected. You might also notice that the front-end template displays a Balances table with some predefined accounts and that a few of those accounts are preconfigured with funds. You can use this sample data to try out operations like transferring funds. Transfer funds from an account Now that you have a blockchain node running on your local computer and you have a front-end template available for performing on-chain operations, you are ready to explore different ways to interact with the blockchain. By default, the front-end template includes several components that allow you to try different common tasks. For this tutorial, you can perform a simple transfer operation that moves funds from one account to another. To transfer funds to an account: In the Balances table, notice the predefined accounts\u2014such as dave\u2014that have no funds associated with them. Under the Balances table, the front-end template also displays a Transfer component. You use this component to transfer funds from one account to another. Copy and paste the address for the dave account to specify the address to which you are transferring funds. Specify at least 1000000000000 as the amount to transfer, then click Submit . Notice that the values in Balances table is updated with the transfer. Check the Events component to see events related to the transfer you just completed. The Substrate blockchain reports the result of asynchronous operations as events, so you can use the Events components to see details about each operation performed as part of the transfer. For example: When the transaction has been completed and included in a block, you see a confirmation message similar to the following: \ud83d\ude09 Finalized. Block hash: 0xda7e9e935abf5a3a2fdb0a27d67cd7a69e628165b5827255af2635ba226411a4 Stop the local node After a successful transfer, you can continue to explore the front-end template components or stop the local Substrate node the state changes you made. With --tmp flag specified when running the node template, stopping the local node stops the blockchain and purge all persistent block data that goes with it so you can start with a clean new state next time you start again. To stop the local Substrate node: Return to the terminal shell where the node output is displayed. Press Control-c to terminate the running process. Verify your terminal returns to the terminal prompt in the substrate-node-template directory. Next steps Congratulations! In this tutorial, you learned: How to start a working Substrate-based blockchain node using the node. How to view and interact with the blockchain node using a front-end user interface. How to make a simple transfer from one account to another. The front-end template includes several additional components for you to experiment with while you're connected to a local development node. You can explore these components on your own or learn more in the following topics: Explore blockchain metadata . Call extrinsic functions . Add a new pallet . Upgrade the runtime . If you experienced any issues with this tutorial or want to provide feedback: Ask questions on Stack Overflow tagged substrate . Contact the Substrate community on Element .","title":"Build a local blockchain"},{"location":"tutorials/build-local-blockchain/#build-a-local-blockchain","text":"As you learned in Blockchain basics , a blockchain consists of decentralized computers\u2014called nodes\u2014to form a network. Substrate provides a flexible, open, and extensible development environment that allows you to design and build fully-customized blockchain nodes to suit your application or business model needs.","title":"Build a local blockchain"},{"location":"tutorials/build-local-blockchain/#get-started","text":"The first step in becoming a blockchain developer is to learn how to compile and launch a single local blockchain node. In this tutorial, you build and start a single node blockchain using a node template. The Substrate node template provides a working single-node blockchain that you can run locally in your development environment. The node template includes several predefined components\u2014such as user accounts and account balances\u2014so that you can experiment with performing common tasks. Without making any changes to the template, you can run a functional node that produces blocks and allows transactions. After you start the local blockchain node, this tutorial illustrates how you can use a Substrate front-end template to view information about blockchain activity and submit a transaction.","title":"Get started"},{"location":"tutorials/build-local-blockchain/#who-is-this-tutorial-for","text":"This tutorial provides a basic introduction to Substrate and prepares a minimal working development environment that you can use to explore further in additional tutorials. It is intended for anyone interested in learning about Substrate and blockchain development. The tutorial assumes you have no prior experience or knowledge of Substrate. You don't need any programming or blockchain experience to complete this tutorial. This is just the first step, but hopefully, it inspires you to continue your journey.","title":"Who is this tutorial for?"},{"location":"tutorials/build-local-blockchain/#how-much-time-do-you-need-to-complete-this-tutorial","text":"This tutorial requires compiling Rust code and takes approximately one to two hours to complete.","title":"How much time do you need to complete this tutorial?"},{"location":"tutorials/build-local-blockchain/#before-you-begin","text":"For this tutorial, you download and use working code. Before you begin, verify the following: You have good internet connection and access to a shell terminal on your local computer. You are generally familiar with software development and use command-line interfaces. You are generally familiar with blockchains and smart contract platforms. You want to learn about the bleeding edge of blockchain development. By completing this tutorial, you will accomplish the following objectives:","title":"Before you begin"},{"location":"tutorials/build-local-blockchain/#tutorial-objectives","text":"By completing this tutorial, you will accomplish the following objectives: Set up a Substrate development environment on your computer. Install the node template to start a Substrate-based blockchain. Install a front-end template to interact with the local blockchain node. Use the front-end template to submit a transaction and view the result.","title":"Tutorial objectives"},{"location":"tutorials/build-local-blockchain/#install-required-packages","text":"Substrate development is easiest on UNIX-based operating systems like macOS or Linux. If you are using Microsoft Windows, refer to the Windows installation page . To install required packages on macOS or Linux: Open a terminal shell on your computer. Locate your operating system in the following table and run the appropriate commands for your development environment. OS Installation commands Ubuntu or Debian sudo apt update && sudo apt install -y git clang curl libssl-dev llvm libudev-dev Arch Linux pacman -Syu --needed --noconfirm curl git clang Fedora sudo dnf update sudo dnf install clang curl git openssl-devel OpenSUSE sudo zypper install clang curl git openssl-devel llvm-devel libudev-devel macOS brew update && brew install openssl Windows Refer to this installation guide . If you are using macOS and do not have Homebrew installed, run the following command to install Homebrew: /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\" After installing Homebrew, run brew install openssl .","title":"Install required packages"},{"location":"tutorials/build-local-blockchain/#install-rust-and-the-rust-toolchain","text":"To install and configure Rust manually: Install rustup by running the following command: curl https://sh.rustup.rs -sSf | sh Configure your current shell to reload your PATH environment variable so that it includes the Cargo bin directory by running the following command: source ~/.cargo/env Configure the Rust toolchain to default to the latest stable version by running the following commands: rustup default stable rustup update Add the nightly release and the nightly WebAssembly ( wasm ) targets by running the following commands: rustup update nightly rustup target add wasm32-unknown-unknown --toolchain nightly Verify your installation by running the following commands: rustc --version rustup show The previous steps walked you through the installation and configuration of Rust and the Rust toolchain so that you could see the full process for yourself. It is also possible to automate the steps using a script. If you want to try installing and configuring Rust using a script, see the [`getsubstrate`](https://getsubstrate.io) automation script.","title":"Install Rust and the Rust toolchain"},{"location":"tutorials/build-local-blockchain/#set-up-a-development-environment","text":"After you install the required packages and the Rust compiler and toolchain, you are ready to set up a development environment on your local computer. You could build a development environment manually using the tools of your choice, but the Substrate Developer Hub has templates to get you started. After you set up the development environment, you can use it in subsequent tutorials as you learn more about building on Substrate.","title":"Set up a development environment"},{"location":"tutorials/build-local-blockchain/#prepare-a-substrate-node","text":"The Substrate node template provides a working development environment so that you can start building on Substrate right away. To compile the Substrate node template: Clone the node template repository using the version latest branch by running the following command: git clone -b latest --depth 1 https://github.com/substrate-developer-hub/substrate-node-template Change to the root of the node template directory by running the following command: cd substrate-node-template Compile the node template by running the following command: cargo build --release You should always use the --release flag to build optimized artifacts.","title":"Prepare a Substrate node"},{"location":"tutorials/build-local-blockchain/#install-the-front-end-template","text":"The front-end template uses ReactJS to render a web browser interface that enables you to interact with the Substrate-based blockchain node. You can use this Front-end template as a starting point for creating user interfaces for your own projects in future. The front-end template requires Yarn and Node.js . If you don't have these tools, install them first. To install the front-end template: Check whether node is installed on your local computer by running the following command: node --version If the command doesn\u2019t return a version number, download and install node by following the instructions for the operating system you use on the Node.js website. The node version should be at least v14 to run the front-end template. Check whether yarn is installed on your local computer by running the following command: yarn --version The yarn version should be at least v3 to run the front-end template. If the command doesn\u2019t return a version number, download and install yarn by running the following command: npm install -g yarn Clone the front-end template repository by running the following command: git clone -b latest --depth 1 https://github.com/substrate-developer-hub/substrate-front-end-template Change to the root of the front-end template directory by running the following command: cd substrate-front-end-template Install the dependencies for the front-end template by running the following command: yarn install","title":"Install the front-end template"},{"location":"tutorials/build-local-blockchain/#start-the-local-node","text":"After your node compiles, you are ready to start exploring what it does using the front-end template. To start the local Substrate node: Open a terminal shell. Change to the root directory where you compiled the Substrate node template. Start the node in development mode by running the following command: ./target/release/node-template --dev --tmp The node-template command-line options specify how you want the running node to operate. In this case, the options specify the following: The --dev option specifies that the node is run as a developer node chain specification. The --tmp option specifies that the node will delete all active data\u2014such as keys, blockchain database, and networking information when you stop the node by pressing Control-c. You can use --tmp option to ensure you have a clean working state any time you stop and restart the node. Verify your node is up and running successfully by reviewing the output displayed in the terminal. The terminal should display output similar to this: 2021-03-16 10:56:51 Running in --dev mode, RPC CORS has been disabled. 2021-03-16 10:56:51 Substrate Node 2021-03-16 10:56:51 \u270c\ufe0f version 3.0.0-8370ddd-x86_64-linux-gnu 2021-03-16 10:56:51 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-16 10:56:51 \ud83d\udccb Chain specification: Development 2021-03-16 10:56:51 \ud83c\udff7 Node name: few-size-5380 2021-03-16 10:56:51 \ud83d\udc64 Role: AUTHORITY 2021-03-16 10:56:51 \ud83d\udcbe Database: RocksDb at /tmp/substrateP1jD7H/chains/dev/db 2021-03-16 10:56:51 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-16 10:56:51 \ud83d\udd28 Initializing Genesis block/state (state: 0x17df\u202604a0, header-hash: 0xc43b\u2026ed16) 2021-03-16 10:56:51 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-16 10:56:51 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-16 10:56:51 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-16 10:56:51 \ud83c\udff7 Local node identity is: 12D3KooWQdU84EJCqDr4aqfhb7dxXU2fzd6i2Rn1XdNtsiM5jvEC 2021-03-16 10:56:51 \ud83d\udce6 Highest known block at #0 ... ... ... 2021-03-16 10:56:56 \ud83d\udca4 Idle (0 peers), best: #2 (0x05bd\u2026de3f), finalized #0 (0xc43b\u2026ed16), \u2b07 0 \u2b06 0 If the number after finalized is increasing, your blockchain is producing new blocks and reaching consensus about the state they describe. We'll look into the details of what's reported in the log output in a later tutorial. For now, it's only important to know that your node is running and producing blocks. Keep the terminal that displays the node output open to continue.","title":"Start the local node"},{"location":"tutorials/build-local-blockchain/#start-the-front-end-template","text":"The Substrate front-end template consists of user interface components to enable you to interact with the Substrate node and perform a few common tasks. To use the front-end template: Open a new terminal shell on your computer, change to the root directory where you installed the front-end template. Start the Front-end template by running the following command: yarn start Open http://localhost:8000 in a browser to view the front-end template. The top section has an Account selection list for selecting the account to work with when you want to perform on-chain operations. The top section of the template also displays information about the chain to which you're connected. You might also notice that the front-end template displays a Balances table with some predefined accounts and that a few of those accounts are preconfigured with funds. You can use this sample data to try out operations like transferring funds.","title":"Start the front-end template"},{"location":"tutorials/build-local-blockchain/#transfer-funds-from-an-account","text":"Now that you have a blockchain node running on your local computer and you have a front-end template available for performing on-chain operations, you are ready to explore different ways to interact with the blockchain. By default, the front-end template includes several components that allow you to try different common tasks. For this tutorial, you can perform a simple transfer operation that moves funds from one account to another. To transfer funds to an account: In the Balances table, notice the predefined accounts\u2014such as dave\u2014that have no funds associated with them. Under the Balances table, the front-end template also displays a Transfer component. You use this component to transfer funds from one account to another. Copy and paste the address for the dave account to specify the address to which you are transferring funds. Specify at least 1000000000000 as the amount to transfer, then click Submit . Notice that the values in Balances table is updated with the transfer. Check the Events component to see events related to the transfer you just completed. The Substrate blockchain reports the result of asynchronous operations as events, so you can use the Events components to see details about each operation performed as part of the transfer. For example: When the transaction has been completed and included in a block, you see a confirmation message similar to the following: \ud83d\ude09 Finalized. Block hash: 0xda7e9e935abf5a3a2fdb0a27d67cd7a69e628165b5827255af2635ba226411a4","title":"Transfer funds from an account"},{"location":"tutorials/build-local-blockchain/#stop-the-local-node","text":"After a successful transfer, you can continue to explore the front-end template components or stop the local Substrate node the state changes you made. With --tmp flag specified when running the node template, stopping the local node stops the blockchain and purge all persistent block data that goes with it so you can start with a clean new state next time you start again. To stop the local Substrate node: Return to the terminal shell where the node output is displayed. Press Control-c to terminate the running process. Verify your terminal returns to the terminal prompt in the substrate-node-template directory.","title":"Stop the local node"},{"location":"tutorials/build-local-blockchain/#next-steps","text":"Congratulations! In this tutorial, you learned: How to start a working Substrate-based blockchain node using the node. How to view and interact with the blockchain node using a front-end user interface. How to make a simple transfer from one account to another. The front-end template includes several additional components for you to experiment with while you're connected to a local development node. You can explore these components on your own or learn more in the following topics: Explore blockchain metadata . Call extrinsic functions . Add a new pallet . Upgrade the runtime . If you experienced any issues with this tutorial or want to provide feedback: Ask questions on Stack Overflow tagged substrate . Contact the Substrate community on Element .","title":"Next steps"},{"location":"tutorials/full-private-network-post-edit/","text":"This tutorial provides a basic introduction to the consensus model used in the Substrate node template and how to start a blockchain network with an authority set of private validators . All blockchains require the nodes in the network to agree on the set of messages and their order to successfully create blocks and progress from one block to the next. Each block represents the state of data at a specific point in time and the nodes' agreement on the state is called consensus . There are several different algorithms used to reach consensus, including: Proof of work consensus depends on the computational work done by validator nodes to add valid blocks to the chain. Proof of stake consensus selects the validators add valid blocks to the chain based on the cryptocurrency holdings that they have locked up as a stake in the network. Proof of authority consensus relies on a set of approved account identities to act as validators. The nodes associated with approved accounts have the authority to put transactions into blocks. The Substrate node template uses a proof of authority consensus model also referred to as authority round or Aura consensus. The Aura consensus protocol limits block production to a rotating list of authorized accounts\u2014 authorities \u2014that create blocks in a round robin fashion. In this tutorial, you'll see how this consensus model works in practice, first, by using the predefined accounts that are part of the node template, then by adding a new authority to the approved set. Before you begin Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Create your first Substrate blockchain and have the Substrate node template installed locally. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms. Tutorial objectives By completing this tutorial, you will accomplish the following objectives: Start peer blockchain nodes using predefined accounts. Generate key pairs for use as a network authority. Create a custom chain specification file. Launch a private two-node blockchain network. Start the blockchain using predefined accounts Before you generate keys to start your own private Substrate network, you can learn the fundamental principles using a predefined network specification called local and running under predefined user accounts. This part of the tutorial simulates a private network by running two Substrate nodes on a single local computer using predefined accounts that are named alice and bob . Start the first blockchain node To start the blockchain: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/alice --chain local The command prompts you to confirm the operation: bash Are you sure to remove \"/tmp/alice/chains/local_testnet/db\"? [y/N]: Type y to confirm that you want to remove the chain data. You should always remove old chain data when starting a new network. Start the local blockchain node using the alice account by running the following command: bash ./target/release/node-template \\ --base-path /tmp/alice \\ --chain local \\ --alice \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --node-key 0000000000000000000000000000000000000000000000000000000000000001 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator Review the command-line options Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain local Specifies the chain specification to use. Valid predefined chain specifications include local , development , and staging . --alice Adds the predefined keys for the alice account to the node's keystore. With this setting, the alice account is used for block production and finalization. --port 30333 Specifies the port to listen on for peer-to-peer ( p2p ) traffic. Because this tutorial uses two nodes running on the same physical computer to simulate a network, you must explicitly specify a different port for at least one account. --ws-port 9945 Specifies the port to listen on for incoming WebSocket traffic. The default port is 9944 . This tutorial uses a custom web socket port number ( 9945 ). --rpc-port 9933 Specifies the port to listen on for incoming RPC traffic. The default port is 9933 . --node-key <key> Specifies the Ed25519 secret key to use for libp2p networking. You should only use this option for development and testing. --telemetry-url Specifies where to send telemetry data. For this tutorial, you can send telemetry data to a server hosted by Parity that is available for anyone to use. --validator Specifies that this node participates in block production and finalization for the network. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help Review the node messages displayed If the node starts successfully, the terminal displays messages describing network operations. For example, you should see output similar to this: 2021-03-10 17:34:27 Substrate Node 2021-03-10 17:34:27 \u270c\ufe0f version 3.0.0-1c5b984-x86_64-linux-gnu 2021-03-10 17:34:27 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-10 17:34:27 \ud83d\udccb Chain specification: Local Testnet 2021-03-10 17:34:27 \ud83c\udff7 Node name: Alice 2021-03-10 17:34:27 \ud83d\udc64 Role: AUTHORITY 2021-03-10 17:34:27 \ud83d\udcbe Database: RocksDb at /tmp/alice/chains/local_testnet/db 2021-03-10 17:34:27 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-10 17:34:27 \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) 2021-03-10 17:34:27 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-10 17:34:27 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-10 17:34:27 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-10 17:34:27 \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:34:27 \ud83d\udce6 Highest known block at #0 2021-03-10 17:34:27 \u303d\ufe0f Prometheus server started at 127.0.0.1:9615 2021-03-10 17:34:27 Listening for new connections on 127.0.0.1:9945. 2021-03-10 17:34:32 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 ... In particular, you should note the following messages in the output: \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) identifies the initial or genesis block that the node is using. When you start the next node, verify that these values are the same. \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp specifies a string that uniquely identifies this node. This string is determined by the --node-key that was used to start the node using the alice account. You use this string to identify the node to connect to when you start a second node. 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 indicates that there are no other nodes in the network and that no blocks are being produced. Another node must join the network before blocks can start to be produced. Attach a frontend to see information about the node You can see a lot of information about node operations by watching the output it produces in your terminal. You can also view information about node operations by using a web browser to access the Polkadot-JS graphical user interface. To view node operations using the Polkadot-JS application: Open a web browser. Navigate to the Polkadot-JS Explorer . The Polkadot-JS Explorer link uses the rpc URL parameter to connect to the local node. Some browsers have ad blocking features that prevent connecting to a local node. If you have trouble connecting to the local node, see if you have ad blocking enabled and disable it, as needed. If your browser prevents connections to a local node, try using another browser, like Chromium or downloading and hosting the Polkadot-JS application locally. Click the network icon displayed in the top left corner of the Polkadot-JS Explorer page. Expand DEVELOPMENT in the list of networks available. Verify the custom endpoint is set to your local host and the port number you specified for incoming WebSocket traffic. You can use a single instance of the Polkadot-JS application to connect to different networks, nodes, and endpoints. You should now see something like this displayed in the Polkadot-JS Explorer Network page. Add a second node to the blockchain network Now that the node you started using the alice account keys is running, you can add another node to the network using the bob account. Because you are joining a network that is already running, you can use the running node to identify the network for the new node to join. The commands are similar to the ones you used before, but with a few important differences. To add a node to the running blockchain: Open a new terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/bob --chain local -y By adding -y to the command, you can remove chain data without being prompted you to confirm the operation. Start a second local blockchain node using the bob account by running the following command: bash ./target/release/node-template \\ --base-path /tmp/bob \\ --chain local \\ --bob \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp Note the following differences between this command and the previous one: Because the two nodes are running on the same physical computer, you must specify different values for the --base-path , --port , --ws-port , and --rpc-port options. This command includes the --bootnodes option and specifies a single boot node, the node started by alice . The --bootnodes option specifies the following information: ip4 indicates that the IP address for the node uses the IPv4 format 127.0.0.1 specifies the IP address for the running node. In this case, the address for the localhost . tcp specifies TCP as the protocol used for peer-to-peer communication. 30333 specifies the port number used for peer-to-peer communication. In this case, the port number for TCP traffic. 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp identifies the running node to communicate with for this network. In this case, the identifier for the node started using the alice account. Verify blocks are produced and finalized After you start the second node, the nodes should connect to each other as peers and start producing blocks. To verify blocks are being finalized: Verify that you see lines similar to the following in the terminal where you started the first node: ... 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/<your computer's LAN IP>/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:33 \ud83d\udca4 Idle (1 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 1.0kiB/s \u2b06 1.0kiB/s 2021-03-10 17:47:36 \ud83d\ude4c Starting consensus session on top of parent 0x9d07d1757a9ca248e58141ce52a11fca37f71007dec16650b87a853f0d4c7cce 2021-03-10 17:47:36 \ud83c\udf81 Prepared block for proposing at 1 [hash: 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f; parent_hash: 0x9d07\u20267cce; extrinsics (1): [0x768a\u2026a9e2]] 2021-03-10 17:47:36 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x4841d8b2e62483fa4702b3ddcd1b603803842374dcdc1e9533ad407708b33dd8, previously 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f. 2021-03-10 17:47:36 \u2728 Imported #1 (0x4841\u20263dd8) 2021-03-10 17:47:36 \u2728 Imported #1 (0xb241\u20262ae8) 2021-03-10 17:47:38 \ud83d\udca4 Idle (1 peers), best: #1 (0x4841\u20263dd8), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:42 \u267b\ufe0f Reorg on #1,0x4841\u20263dd8 to #2,0x8b6a\u2026dce6, common ancestor #0,0x9d07\u20267cce 2021-03-10 17:47:42 \u2728 Imported #2 (0x8b6a\u2026dce6) 2021-03-10 17:47:43 \ud83d\udca4 Idle (1 peers), best: #2 (0x8b6a\u2026dce6), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:48 \ud83d\ude4c Starting consensus session on top of parent 0x8b6a3ab2fe9891b1af008ea0d92dae9bc84cfa5578231e81066d47928822dce6 2021-03-10 17:47:48 \ud83c\udf81 Prepared block for proposing at 3 [hash: 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a; parent_hash: 0x8b6a\u2026dce6; extrinsics (1): [0x82ac\u20262f20]] 2021-03-10 17:47:48 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x34d608dd8be6b82bef4a7aaae1ec80930a5c4b8cf9bdc99013410e91544f3a2a, previously 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a. 2021-03-10 17:47:48 \u2728 Imported #3 (0x34d6\u20263a2a) 2021-03-10 17:47:48 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #0 (0x9d07\u20267cce), \u2b07 0.7kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:53 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #1 (0xb241\u20262ae8), \u2b07 0.6kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:54 \u2728 Imported #4 (0x2b8a\u2026fdc4) 2021-03-10 17:47:58 \ud83d\udca4 Idle (1 peers), best: #4 (0x2b8a\u2026fdc4), finalized #2 (0x8b6a\u2026dce6), \u2b07 0.7kiB/s \u2b06 0.6kiB/s ... These lines show that the first node started by alice has a one peer ( 1 peers ), they have produced some blocks ( best: #4 (0x2b8a\u2026fdc4) ), and that the blocks are being finalized ( finalized #2 (0x8b6a\u2026dce6) ). Verify that you see similar output in the terminal where you started the second node. Open the Polkadot-JS Explorer to verify the network is producing and finalizing blocks. Shut down both nodes by pressing Control-c in each terminal shell. Generate your own keys Now that you know how to start and connect running nodes as peers using command-line options, you are ready to generate your own secret keys instead of using the predefined account keys. It's important to remember that each participant in the blockchain network is responsible for generating unique keys. Key generation options There are several ways you can generate keys. For example, you can generate key pairs using a node-template subcommand, the standalone Subkey command-line program, the Polkadot-JS application, or third-party key generation utilities. Although you could use predefined key pairs to complete this tutorial, you would never use those keys in a production environment. Instead of using predefined keys or the more secure subkey program, this tutorial illustrates how to generate keys locally using the Substrate node template and the key subcommand. Generate local keys using the node template You have already used the some command-line options to start your local blockchain node using the predefined alice and bob accounts. You can also use command-line options to generate random keys to use with Substrate. For this tutorial, you can remain connected to the internet and use your local node to generate your keys. As a best practice, you should never be connected to the internet when you generate keys for a production blockchain. For a production environment, you should disconnect from the internet before you generate any keys. To generate keys using the node template: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Generate a random secret phrase and keys by running the following command: bash ./target/release/node-template key generate --scheme Sr25519 --password-interactive Type a password for the generated keys. The command generates keys and displays output similar to the following: bash Secret phrase: pig giraffe ceiling enter weird liar orange decline behind total despair fly Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Account ID: 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW SS58 Address: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW You now have the Sr25519 key for producing blocks using aura for one node. In this example, the Sr25519 public key for the account is: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW Use the secret seed for the account you just generated to derive keys using the Ed25519 signature scheme by running the following command: bash ./target/release/node-template key inspect --password-interactive --scheme Ed25519 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Type the password you used to the generated keys. The command displays output similar to the following: bash Secret Key URI `0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f` is account: Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Account ID: 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN SS58 Address: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN You now have the Ed25519 key for finalizing blocks using grandpa for one node. In this example, the Ed25519 public key for the account is: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN Generate a second set of keys For this tutorial, the private network consists of just two nodes, so you need two sets of keys. You have a few options to continue the tutorial: You can use the keys for one or two of the predefined accounts. You can repeat the steps in the previous section using a different identity on another computer to generate a second key pair. You can recruit other participants to generate the keys required to join your private network. For illustration purposes, the second set of keys used in this tutorial are: Sr25519: 5EJPj83tJuJtTVE2v7B9ehfM7jNT44CBFaPWicvBwYyUKBS6 for aura . Ed25519: 5FeJQsfmbbJLTH1pvehBxrZrT5kHvJFj84ZaY5LK7NU87gZS for grandpa . Create a custom chain specification After you generate the keys to use with your blockchain, you are ready to create a custom chain specification using those key pairs then share your custom chain specification with trusted network participants called validators . To enable others to participate in your blockchain network, you should ensure that they generate their own keys. If other participants have generated their key pairs, you can create a custom chain specification to replace the local chain specification that you used previously. This tutorial illustrates how to create a two-node network. You can follow the same steps to add more nodes to your network. Modify an existing chain specification Previously, you added nodes to the blockchain using the predefined local chain specification using the --chain local command-line option. Instead of writing a completely new chain specification, you can modify the one that you have used before. To create a new chain specification based on an existing specification: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Export the local chain specification to a file named customSpec.json by running the following command: bash ./target/release/node-template build-spec --disable-default-bootnode --chain local > customSpec.json If you open the customSpec.json file in a text editor, you would see that it contains several fields, including a large blob that contains the Wasm binary for the runtime you built using the cargo build --release command. Instead of viewing the entire file, you can preview the first and last few lines to see the fields you need to change. Preview the first few fields in the customSpec.json file by running the following command: bash head customSpec.json The command displays the first fields from the file. For example: bash { \"name\": \"Local Testnet\", \"id\": \"local_testnet\", \"chainType\": \"Local\", \"bootNodes\": [], \"telemetryEndpoints\": null, \"protocolId\": null, \"properties\": null, \"consensusEngine\": null, \"codeSubstitutes\": {}, Preview the last fields in the customSpec.json file by running the following command: bash tail -n 80 customSpec.json This command displays the last sections following the Wasm binary field, including the details for several of the pallets\u2014such as the sudo and balances pallets\u2014that are used in the runtime. Open the customSpec.json file in a text editor. Modify the name field to identify this chain specification as a custom chain specification. For example: json \"name\": \"My Custom Testnet\", Modify aura field to specify the nodes with the authority to create blocks by adding the Sr25519 SS58 address keys for each network participant. json \"aura\": { \"authorities\": [ \"5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW\", \"5EJPj83tJuJtTVE2v7B9ehfM7jNT44CBFaPWicvBwYyUKBS6\" ] }, Modify the grandpa field to specify the nodes with the authority to finalize blocks by adding the Ed25519 SS58 address keys for each network participant. json \"grandpa\": { \"authorities\": [ [ \"5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN\", 1 ], [ \"5FeJQsfmbbJLTH1pvehBxrZrT5kHvJFj84ZaY5LK7NU87gZS\", 1 ] ] }, Note that there are two data values for the authorities field in the grandpa section. The first value is the address key. The second value is used to support weighted votes . In this example, each validator has a weight of 1 vote. Save your changes and close the file. Add validators As you have just seen, you can add and change the authority addresses in a chain specification by modifying the aura and grandpa sections. You can use this technique to add as many validators as you like. To add validators: Modify the aura section to include Sr25519 addresses. Modify the grandpa section to include Ed25519 addresses and a voting weight. Be sure to use unique keys for each validator. If two validators have the same keys, they produce conflicting blocks. For additional information about working with key pairs and signatures, see Public-Key cryptography . Convert the chain specification to use the raw format After you prepare a chain specification with the information you want to use, you must convert it into a raw specification before it can be used. The raw chain specification includes the same information as the unconverted specification. However, the raw chain specification also contains encoded storage keys that the node uses to reference the data in its local storage. Distributing a raw chain specification ensures that each node stores the data using the proper storage keys. To convert a chain specification to use the raw format: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Convert the customSpec.json chain specification to the raw format with the file name customSpecRaw.json by running the following command: bash ./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode > customSpecRaw.json Share the chain specification with others If you are creating a private blockchain network to share with other participants, ensure that only one person creates the chain specification and shares the resulting raw version of that specification\u2014for example, the customSpecRaw.json file\u2014with all of the other validators in the network. Because the Rust compiler produces optimized WebAssembly binaries that aren't deterministically reproducible, each person who generates the Wasm runtime produces a slightly different Wasm blob. To ensure determinism, all participants in the blockchain network must use exactly the same raw chain specification file. For more information about this issue, see Hunting down a non-determinism-bug in our Rust Wasm build . Launch the private network After you distribute the custom chain specification to all network participants, you're ready to launch your own private blockchain. The steps are similar to the steps you followed in Start the blockchain using predefined accounts . To continue with this part of the tutorial, you are no longer using a single physical computer or a single binary. To continue, verify the following: You have generated or collected the account keys for at least two authority accounts. You have updated your custom chain specification to include the keys for block production ( aura ) and block finalization ( grandpa ). You have converted your custom chain specification to raw format and distributed the raw chain specification to the nodes participating in the private network. If you have completed these steps, you are ready to start the first node in the private blockchain. Start the first node As the first participant in the private blockchain network, you are responsible for starting the first node, called the bootnode . To start the first node: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node01 --chain local -y Start the first node using the custom chain specification by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node01 \\ --chain ./customSpecRaw.json \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode01 Note the following changes to the command you are running to start the node: Instead of the predefined --alice account, you are using your own keys. You'll add your keys to the keystore in a separate step. The --chain command-line option specifies the custom chain specification. The --name command-line option enables you to give your node a human-readable name in the telemetry UI. The --rpc-methods Unsafe command-line option allows you to continue the tutorial using an unsafe communication mode because your blockchain is not being used in a production setting. Verify that you see output similar to the following: bash 2021-11-03 15:32:14 Substrate Node 2021-11-03 15:32:14 \u270c\ufe0f version 3.0.0-monthly-2021-09+1-bf52814-x86_64-macos 2021-11-03 15:32:14 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-11-03 15:32:14 \ud83d\udccb Chain specification: My Custom Testnet 2021-11-03 15:32:14 \ud83c\udff7 Node name: MyNode01 2021-11-03 15:32:14 \ud83d\udc64 Role: AUTHORITY 2021-11-03 15:32:14 \ud83d\udcbe Database: RocksDb at /tmp/node01/chains/local_testnet/db 2021-11-03 15:32:14 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-11-03 15:32:15 \ud83d\udd28 Initializing Genesis block/state (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) 2021-11-03 15:32:15 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-11-03 15:32:15 \u23f1 Loaded block-time = 6s from block 0x6c78abc724f83285d1487ddcb1f948a2773cb38219c4674f84c727833be737de 2021-11-03 15:32:15 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-11-03 15:32:15 \ud83c\udff7 Local node identity is: 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX 2021-11-03 15:32:15 \ud83d\udce6 Highest known block at #0 2021-11-03 15:32:15 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2021-11-03 15:32:15 Listening for new connections on 127.0.0.1:9945. 2021-11-03 15:32:20 \ud83d\udca4 Idle (0 peers), best: #0 (0x6c78\u202637de), finalized #0 (0x6c78\u202637de), \u2b07 0 \u2b06 0 Take note of the following information: The output shows the genesis block being initialized with the block hash (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) . The output specifies the Local node identity for your node. In this example, the node identity is 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX . The output specifies the IP address used for the node is the local host 127.0.0.1 . These values are for this specific tutorial example. The values will be different for your node and you must provide the values for your node to other network participants to connect to the bootnode. Add keys to the keystore After you start the first node, no blocks are yet produced. The next step is to add two types of keys to the keystore for each node in the network. For each node: Add the aura authority keys to enable block production . Add the grandpa authority keys to enable block finalization . There are several ways you can insert keys into the keystore. For this tutorial, you can use the key subcommand to insert locally-generated secret keys. To insert keys into the keystore: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Insert the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri <your-secret-seed> \\ --password-interactive \\ --key-type aura This example uses the secret seed generated from the key subcommand into the keystore. In this tutorial, the secret seed generated was 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 , so the --suri command-line option specifies that string to insert the key into the keystore: bash --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 You can also insert a key from a specified file location. For information about the command-line options available, run the following command: bash ./target/release/node-template key insert --help Insert the grandpa secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri <your-secret-key> \\ --password-interactive \\ --key-type gran Verify that your keys are in the keystore for node01 by running the following command: bash ls /tmp/node01/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 6772616e1441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 Enable other participants to join You can now allow other validators to join the network using the --bootnodes and --validator command-line options. To add a second validator to the private network: Open a terminal shell on a second computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node02 --chain local -y Start a second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Add the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri <second-participant-secret-seed> \\ --password-interactive \\ --key-type aura Note that this command uses the second participant's secret key and that the aura key type is required to enable block production. Add the grandpa secret key generated from the key subcommand to the local keystore by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri <second-participant-secret-seed> \\ --password-interactive \\ --key-type gran Note that this command uses the second participant's secret key and that the gran key type is required to enable block finalization. Block finalization requires at least two-thirds of the validators to add their keys to their respective keystores. Because this network is configured with two validators in the chain specification, block finalization starts after the second node has added its keys. Verify that your keys are in the keystore for node02 by running the following command: bash ls /tmp/node02/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 6772616e1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Substrate nodes require a restart after inserting a grandpa key, so you must shut down and restart nodes before you see blocks being finalized. Shut down the node by pressing Control-c. Restart the second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... After both nodes have added their keys to their respective keystores and been restarted, you should see the same genesis block and state root hashes. You should also see that each node has one peer ( 1 peers ), and they have produced a block proposal ( best: #2 (0xe111\u2026c084) ). After a few seconds, you should see new blocks being finalized. ```bash ``` Next steps You have now seen how you can start a private blockchain with trusted participants. In this tutorial you learned: How to start and stop peer blockchain nodes. How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification. To learn more about the topics introduced in this tutorial, see the following sections: Executor for more information about the WebAssembly runtime that is a core component of the chain specification. Accounts and Key management for more information about key generation and storage options. Cryptography for more information about the signature schemes used for different keys.","title":"Start a private network"},{"location":"tutorials/full-private-network-post-edit/#before-you-begin","text":"Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Create your first Substrate blockchain and have the Substrate node template installed locally. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms.","title":"Before you begin"},{"location":"tutorials/full-private-network-post-edit/#tutorial-objectives","text":"By completing this tutorial, you will accomplish the following objectives: Start peer blockchain nodes using predefined accounts. Generate key pairs for use as a network authority. Create a custom chain specification file. Launch a private two-node blockchain network.","title":"Tutorial objectives"},{"location":"tutorials/full-private-network-post-edit/#start-the-blockchain-using-predefined-accounts","text":"Before you generate keys to start your own private Substrate network, you can learn the fundamental principles using a predefined network specification called local and running under predefined user accounts. This part of the tutorial simulates a private network by running two Substrate nodes on a single local computer using predefined accounts that are named alice and bob .","title":"Start the blockchain using predefined accounts"},{"location":"tutorials/full-private-network-post-edit/#start-the-first-blockchain-node","text":"To start the blockchain: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/alice --chain local The command prompts you to confirm the operation: bash Are you sure to remove \"/tmp/alice/chains/local_testnet/db\"? [y/N]: Type y to confirm that you want to remove the chain data. You should always remove old chain data when starting a new network. Start the local blockchain node using the alice account by running the following command: bash ./target/release/node-template \\ --base-path /tmp/alice \\ --chain local \\ --alice \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --node-key 0000000000000000000000000000000000000000000000000000000000000001 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator","title":"Start the first blockchain node"},{"location":"tutorials/full-private-network-post-edit/#review-the-command-line-options","text":"Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain local Specifies the chain specification to use. Valid predefined chain specifications include local , development , and staging . --alice Adds the predefined keys for the alice account to the node's keystore. With this setting, the alice account is used for block production and finalization. --port 30333 Specifies the port to listen on for peer-to-peer ( p2p ) traffic. Because this tutorial uses two nodes running on the same physical computer to simulate a network, you must explicitly specify a different port for at least one account. --ws-port 9945 Specifies the port to listen on for incoming WebSocket traffic. The default port is 9944 . This tutorial uses a custom web socket port number ( 9945 ). --rpc-port 9933 Specifies the port to listen on for incoming RPC traffic. The default port is 9933 . --node-key <key> Specifies the Ed25519 secret key to use for libp2p networking. You should only use this option for development and testing. --telemetry-url Specifies where to send telemetry data. For this tutorial, you can send telemetry data to a server hosted by Parity that is available for anyone to use. --validator Specifies that this node participates in block production and finalization for the network. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help","title":"Review the command-line options"},{"location":"tutorials/full-private-network-post-edit/#review-the-node-messages-displayed","text":"If the node starts successfully, the terminal displays messages describing network operations. For example, you should see output similar to this: 2021-03-10 17:34:27 Substrate Node 2021-03-10 17:34:27 \u270c\ufe0f version 3.0.0-1c5b984-x86_64-linux-gnu 2021-03-10 17:34:27 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-10 17:34:27 \ud83d\udccb Chain specification: Local Testnet 2021-03-10 17:34:27 \ud83c\udff7 Node name: Alice 2021-03-10 17:34:27 \ud83d\udc64 Role: AUTHORITY 2021-03-10 17:34:27 \ud83d\udcbe Database: RocksDb at /tmp/alice/chains/local_testnet/db 2021-03-10 17:34:27 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-10 17:34:27 \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) 2021-03-10 17:34:27 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-10 17:34:27 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-10 17:34:27 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-10 17:34:27 \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:34:27 \ud83d\udce6 Highest known block at #0 2021-03-10 17:34:27 \u303d\ufe0f Prometheus server started at 127.0.0.1:9615 2021-03-10 17:34:27 Listening for new connections on 127.0.0.1:9945. 2021-03-10 17:34:32 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 ... In particular, you should note the following messages in the output: \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) identifies the initial or genesis block that the node is using. When you start the next node, verify that these values are the same. \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp specifies a string that uniquely identifies this node. This string is determined by the --node-key that was used to start the node using the alice account. You use this string to identify the node to connect to when you start a second node. 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 indicates that there are no other nodes in the network and that no blocks are being produced. Another node must join the network before blocks can start to be produced.","title":"Review the node messages displayed"},{"location":"tutorials/full-private-network-post-edit/#attach-a-frontend-to-see-information-about-the-node","text":"You can see a lot of information about node operations by watching the output it produces in your terminal. You can also view information about node operations by using a web browser to access the Polkadot-JS graphical user interface. To view node operations using the Polkadot-JS application: Open a web browser. Navigate to the Polkadot-JS Explorer . The Polkadot-JS Explorer link uses the rpc URL parameter to connect to the local node. Some browsers have ad blocking features that prevent connecting to a local node. If you have trouble connecting to the local node, see if you have ad blocking enabled and disable it, as needed. If your browser prevents connections to a local node, try using another browser, like Chromium or downloading and hosting the Polkadot-JS application locally. Click the network icon displayed in the top left corner of the Polkadot-JS Explorer page. Expand DEVELOPMENT in the list of networks available. Verify the custom endpoint is set to your local host and the port number you specified for incoming WebSocket traffic. You can use a single instance of the Polkadot-JS application to connect to different networks, nodes, and endpoints. You should now see something like this displayed in the Polkadot-JS Explorer Network page.","title":"Attach a frontend to see information about the node"},{"location":"tutorials/full-private-network-post-edit/#add-a-second-node-to-the-blockchain-network","text":"Now that the node you started using the alice account keys is running, you can add another node to the network using the bob account. Because you are joining a network that is already running, you can use the running node to identify the network for the new node to join. The commands are similar to the ones you used before, but with a few important differences. To add a node to the running blockchain: Open a new terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/bob --chain local -y By adding -y to the command, you can remove chain data without being prompted you to confirm the operation. Start a second local blockchain node using the bob account by running the following command: bash ./target/release/node-template \\ --base-path /tmp/bob \\ --chain local \\ --bob \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp Note the following differences between this command and the previous one: Because the two nodes are running on the same physical computer, you must specify different values for the --base-path , --port , --ws-port , and --rpc-port options. This command includes the --bootnodes option and specifies a single boot node, the node started by alice . The --bootnodes option specifies the following information: ip4 indicates that the IP address for the node uses the IPv4 format 127.0.0.1 specifies the IP address for the running node. In this case, the address for the localhost . tcp specifies TCP as the protocol used for peer-to-peer communication. 30333 specifies the port number used for peer-to-peer communication. In this case, the port number for TCP traffic. 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp identifies the running node to communicate with for this network. In this case, the identifier for the node started using the alice account.","title":"Add a second node to the blockchain network"},{"location":"tutorials/full-private-network-post-edit/#verify-blocks-are-produced-and-finalized","text":"After you start the second node, the nodes should connect to each other as peers and start producing blocks. To verify blocks are being finalized: Verify that you see lines similar to the following in the terminal where you started the first node: ... 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/<your computer's LAN IP>/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:33 \ud83d\udca4 Idle (1 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 1.0kiB/s \u2b06 1.0kiB/s 2021-03-10 17:47:36 \ud83d\ude4c Starting consensus session on top of parent 0x9d07d1757a9ca248e58141ce52a11fca37f71007dec16650b87a853f0d4c7cce 2021-03-10 17:47:36 \ud83c\udf81 Prepared block for proposing at 1 [hash: 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f; parent_hash: 0x9d07\u20267cce; extrinsics (1): [0x768a\u2026a9e2]] 2021-03-10 17:47:36 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x4841d8b2e62483fa4702b3ddcd1b603803842374dcdc1e9533ad407708b33dd8, previously 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f. 2021-03-10 17:47:36 \u2728 Imported #1 (0x4841\u20263dd8) 2021-03-10 17:47:36 \u2728 Imported #1 (0xb241\u20262ae8) 2021-03-10 17:47:38 \ud83d\udca4 Idle (1 peers), best: #1 (0x4841\u20263dd8), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:42 \u267b\ufe0f Reorg on #1,0x4841\u20263dd8 to #2,0x8b6a\u2026dce6, common ancestor #0,0x9d07\u20267cce 2021-03-10 17:47:42 \u2728 Imported #2 (0x8b6a\u2026dce6) 2021-03-10 17:47:43 \ud83d\udca4 Idle (1 peers), best: #2 (0x8b6a\u2026dce6), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:48 \ud83d\ude4c Starting consensus session on top of parent 0x8b6a3ab2fe9891b1af008ea0d92dae9bc84cfa5578231e81066d47928822dce6 2021-03-10 17:47:48 \ud83c\udf81 Prepared block for proposing at 3 [hash: 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a; parent_hash: 0x8b6a\u2026dce6; extrinsics (1): [0x82ac\u20262f20]] 2021-03-10 17:47:48 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x34d608dd8be6b82bef4a7aaae1ec80930a5c4b8cf9bdc99013410e91544f3a2a, previously 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a. 2021-03-10 17:47:48 \u2728 Imported #3 (0x34d6\u20263a2a) 2021-03-10 17:47:48 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #0 (0x9d07\u20267cce), \u2b07 0.7kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:53 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #1 (0xb241\u20262ae8), \u2b07 0.6kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:54 \u2728 Imported #4 (0x2b8a\u2026fdc4) 2021-03-10 17:47:58 \ud83d\udca4 Idle (1 peers), best: #4 (0x2b8a\u2026fdc4), finalized #2 (0x8b6a\u2026dce6), \u2b07 0.7kiB/s \u2b06 0.6kiB/s ... These lines show that the first node started by alice has a one peer ( 1 peers ), they have produced some blocks ( best: #4 (0x2b8a\u2026fdc4) ), and that the blocks are being finalized ( finalized #2 (0x8b6a\u2026dce6) ). Verify that you see similar output in the terminal where you started the second node. Open the Polkadot-JS Explorer to verify the network is producing and finalizing blocks. Shut down both nodes by pressing Control-c in each terminal shell.","title":"Verify blocks are produced and finalized"},{"location":"tutorials/full-private-network-post-edit/#generate-your-own-keys","text":"Now that you know how to start and connect running nodes as peers using command-line options, you are ready to generate your own secret keys instead of using the predefined account keys. It's important to remember that each participant in the blockchain network is responsible for generating unique keys.","title":"Generate your own keys"},{"location":"tutorials/full-private-network-post-edit/#key-generation-options","text":"There are several ways you can generate keys. For example, you can generate key pairs using a node-template subcommand, the standalone Subkey command-line program, the Polkadot-JS application, or third-party key generation utilities. Although you could use predefined key pairs to complete this tutorial, you would never use those keys in a production environment. Instead of using predefined keys or the more secure subkey program, this tutorial illustrates how to generate keys locally using the Substrate node template and the key subcommand.","title":"Key generation options"},{"location":"tutorials/full-private-network-post-edit/#generate-local-keys-using-the-node-template","text":"You have already used the some command-line options to start your local blockchain node using the predefined alice and bob accounts. You can also use command-line options to generate random keys to use with Substrate. For this tutorial, you can remain connected to the internet and use your local node to generate your keys. As a best practice, you should never be connected to the internet when you generate keys for a production blockchain. For a production environment, you should disconnect from the internet before you generate any keys. To generate keys using the node template: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Generate a random secret phrase and keys by running the following command: bash ./target/release/node-template key generate --scheme Sr25519 --password-interactive Type a password for the generated keys. The command generates keys and displays output similar to the following: bash Secret phrase: pig giraffe ceiling enter weird liar orange decline behind total despair fly Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Account ID: 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW SS58 Address: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW You now have the Sr25519 key for producing blocks using aura for one node. In this example, the Sr25519 public key for the account is: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW Use the secret seed for the account you just generated to derive keys using the Ed25519 signature scheme by running the following command: bash ./target/release/node-template key inspect --password-interactive --scheme Ed25519 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Type the password you used to the generated keys. The command displays output similar to the following: bash Secret Key URI `0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f` is account: Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Account ID: 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN SS58 Address: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN You now have the Ed25519 key for finalizing blocks using grandpa for one node. In this example, the Ed25519 public key for the account is: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN","title":"Generate local keys using the node template"},{"location":"tutorials/full-private-network-post-edit/#generate-a-second-set-of-keys","text":"For this tutorial, the private network consists of just two nodes, so you need two sets of keys. You have a few options to continue the tutorial: You can use the keys for one or two of the predefined accounts. You can repeat the steps in the previous section using a different identity on another computer to generate a second key pair. You can recruit other participants to generate the keys required to join your private network. For illustration purposes, the second set of keys used in this tutorial are: Sr25519: 5EJPj83tJuJtTVE2v7B9ehfM7jNT44CBFaPWicvBwYyUKBS6 for aura . Ed25519: 5FeJQsfmbbJLTH1pvehBxrZrT5kHvJFj84ZaY5LK7NU87gZS for grandpa .","title":"Generate a second set of keys"},{"location":"tutorials/full-private-network-post-edit/#create-a-custom-chain-specification","text":"After you generate the keys to use with your blockchain, you are ready to create a custom chain specification using those key pairs then share your custom chain specification with trusted network participants called validators . To enable others to participate in your blockchain network, you should ensure that they generate their own keys. If other participants have generated their key pairs, you can create a custom chain specification to replace the local chain specification that you used previously. This tutorial illustrates how to create a two-node network. You can follow the same steps to add more nodes to your network.","title":"Create a custom chain specification"},{"location":"tutorials/full-private-network-post-edit/#modify-an-existing-chain-specification","text":"Previously, you added nodes to the blockchain using the predefined local chain specification using the --chain local command-line option. Instead of writing a completely new chain specification, you can modify the one that you have used before. To create a new chain specification based on an existing specification: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Export the local chain specification to a file named customSpec.json by running the following command: bash ./target/release/node-template build-spec --disable-default-bootnode --chain local > customSpec.json If you open the customSpec.json file in a text editor, you would see that it contains several fields, including a large blob that contains the Wasm binary for the runtime you built using the cargo build --release command. Instead of viewing the entire file, you can preview the first and last few lines to see the fields you need to change. Preview the first few fields in the customSpec.json file by running the following command: bash head customSpec.json The command displays the first fields from the file. For example: bash { \"name\": \"Local Testnet\", \"id\": \"local_testnet\", \"chainType\": \"Local\", \"bootNodes\": [], \"telemetryEndpoints\": null, \"protocolId\": null, \"properties\": null, \"consensusEngine\": null, \"codeSubstitutes\": {}, Preview the last fields in the customSpec.json file by running the following command: bash tail -n 80 customSpec.json This command displays the last sections following the Wasm binary field, including the details for several of the pallets\u2014such as the sudo and balances pallets\u2014that are used in the runtime. Open the customSpec.json file in a text editor. Modify the name field to identify this chain specification as a custom chain specification. For example: json \"name\": \"My Custom Testnet\", Modify aura field to specify the nodes with the authority to create blocks by adding the Sr25519 SS58 address keys for each network participant. json \"aura\": { \"authorities\": [ \"5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW\", \"5EJPj83tJuJtTVE2v7B9ehfM7jNT44CBFaPWicvBwYyUKBS6\" ] }, Modify the grandpa field to specify the nodes with the authority to finalize blocks by adding the Ed25519 SS58 address keys for each network participant. json \"grandpa\": { \"authorities\": [ [ \"5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN\", 1 ], [ \"5FeJQsfmbbJLTH1pvehBxrZrT5kHvJFj84ZaY5LK7NU87gZS\", 1 ] ] }, Note that there are two data values for the authorities field in the grandpa section. The first value is the address key. The second value is used to support weighted votes . In this example, each validator has a weight of 1 vote. Save your changes and close the file.","title":"Modify an existing chain specification"},{"location":"tutorials/full-private-network-post-edit/#add-validators","text":"As you have just seen, you can add and change the authority addresses in a chain specification by modifying the aura and grandpa sections. You can use this technique to add as many validators as you like. To add validators: Modify the aura section to include Sr25519 addresses. Modify the grandpa section to include Ed25519 addresses and a voting weight. Be sure to use unique keys for each validator. If two validators have the same keys, they produce conflicting blocks. For additional information about working with key pairs and signatures, see Public-Key cryptography .","title":"Add validators"},{"location":"tutorials/full-private-network-post-edit/#convert-the-chain-specification-to-use-the-raw-format","text":"After you prepare a chain specification with the information you want to use, you must convert it into a raw specification before it can be used. The raw chain specification includes the same information as the unconverted specification. However, the raw chain specification also contains encoded storage keys that the node uses to reference the data in its local storage. Distributing a raw chain specification ensures that each node stores the data using the proper storage keys. To convert a chain specification to use the raw format: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Convert the customSpec.json chain specification to the raw format with the file name customSpecRaw.json by running the following command: bash ./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode > customSpecRaw.json","title":"Convert the chain specification to use the raw format"},{"location":"tutorials/full-private-network-post-edit/#share-the-chain-specification-with-others","text":"If you are creating a private blockchain network to share with other participants, ensure that only one person creates the chain specification and shares the resulting raw version of that specification\u2014for example, the customSpecRaw.json file\u2014with all of the other validators in the network. Because the Rust compiler produces optimized WebAssembly binaries that aren't deterministically reproducible, each person who generates the Wasm runtime produces a slightly different Wasm blob. To ensure determinism, all participants in the blockchain network must use exactly the same raw chain specification file. For more information about this issue, see Hunting down a non-determinism-bug in our Rust Wasm build .","title":"Share the chain specification with others"},{"location":"tutorials/full-private-network-post-edit/#launch-the-private-network","text":"After you distribute the custom chain specification to all network participants, you're ready to launch your own private blockchain. The steps are similar to the steps you followed in Start the blockchain using predefined accounts . To continue with this part of the tutorial, you are no longer using a single physical computer or a single binary. To continue, verify the following: You have generated or collected the account keys for at least two authority accounts. You have updated your custom chain specification to include the keys for block production ( aura ) and block finalization ( grandpa ). You have converted your custom chain specification to raw format and distributed the raw chain specification to the nodes participating in the private network. If you have completed these steps, you are ready to start the first node in the private blockchain.","title":"Launch the private network"},{"location":"tutorials/full-private-network-post-edit/#start-the-first-node","text":"As the first participant in the private blockchain network, you are responsible for starting the first node, called the bootnode . To start the first node: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node01 --chain local -y Start the first node using the custom chain specification by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node01 \\ --chain ./customSpecRaw.json \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode01 Note the following changes to the command you are running to start the node: Instead of the predefined --alice account, you are using your own keys. You'll add your keys to the keystore in a separate step. The --chain command-line option specifies the custom chain specification. The --name command-line option enables you to give your node a human-readable name in the telemetry UI. The --rpc-methods Unsafe command-line option allows you to continue the tutorial using an unsafe communication mode because your blockchain is not being used in a production setting. Verify that you see output similar to the following: bash 2021-11-03 15:32:14 Substrate Node 2021-11-03 15:32:14 \u270c\ufe0f version 3.0.0-monthly-2021-09+1-bf52814-x86_64-macos 2021-11-03 15:32:14 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-11-03 15:32:14 \ud83d\udccb Chain specification: My Custom Testnet 2021-11-03 15:32:14 \ud83c\udff7 Node name: MyNode01 2021-11-03 15:32:14 \ud83d\udc64 Role: AUTHORITY 2021-11-03 15:32:14 \ud83d\udcbe Database: RocksDb at /tmp/node01/chains/local_testnet/db 2021-11-03 15:32:14 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-11-03 15:32:15 \ud83d\udd28 Initializing Genesis block/state (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) 2021-11-03 15:32:15 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-11-03 15:32:15 \u23f1 Loaded block-time = 6s from block 0x6c78abc724f83285d1487ddcb1f948a2773cb38219c4674f84c727833be737de 2021-11-03 15:32:15 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-11-03 15:32:15 \ud83c\udff7 Local node identity is: 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX 2021-11-03 15:32:15 \ud83d\udce6 Highest known block at #0 2021-11-03 15:32:15 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2021-11-03 15:32:15 Listening for new connections on 127.0.0.1:9945. 2021-11-03 15:32:20 \ud83d\udca4 Idle (0 peers), best: #0 (0x6c78\u202637de), finalized #0 (0x6c78\u202637de), \u2b07 0 \u2b06 0 Take note of the following information: The output shows the genesis block being initialized with the block hash (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) . The output specifies the Local node identity for your node. In this example, the node identity is 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX . The output specifies the IP address used for the node is the local host 127.0.0.1 . These values are for this specific tutorial example. The values will be different for your node and you must provide the values for your node to other network participants to connect to the bootnode.","title":"Start the first node"},{"location":"tutorials/full-private-network-post-edit/#add-keys-to-the-keystore","text":"After you start the first node, no blocks are yet produced. The next step is to add two types of keys to the keystore for each node in the network. For each node: Add the aura authority keys to enable block production . Add the grandpa authority keys to enable block finalization . There are several ways you can insert keys into the keystore. For this tutorial, you can use the key subcommand to insert locally-generated secret keys. To insert keys into the keystore: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Insert the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri <your-secret-seed> \\ --password-interactive \\ --key-type aura This example uses the secret seed generated from the key subcommand into the keystore. In this tutorial, the secret seed generated was 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 , so the --suri command-line option specifies that string to insert the key into the keystore: bash --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 You can also insert a key from a specified file location. For information about the command-line options available, run the following command: bash ./target/release/node-template key insert --help Insert the grandpa secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri <your-secret-key> \\ --password-interactive \\ --key-type gran Verify that your keys are in the keystore for node01 by running the following command: bash ls /tmp/node01/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 6772616e1441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04","title":"Add keys to the keystore"},{"location":"tutorials/full-private-network-post-edit/#enable-other-participants-to-join","text":"You can now allow other validators to join the network using the --bootnodes and --validator command-line options. To add a second validator to the private network: Open a terminal shell on a second computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node02 --chain local -y Start a second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Add the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri <second-participant-secret-seed> \\ --password-interactive \\ --key-type aura Note that this command uses the second participant's secret key and that the aura key type is required to enable block production. Add the grandpa secret key generated from the key subcommand to the local keystore by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri <second-participant-secret-seed> \\ --password-interactive \\ --key-type gran Note that this command uses the second participant's secret key and that the gran key type is required to enable block finalization. Block finalization requires at least two-thirds of the validators to add their keys to their respective keystores. Because this network is configured with two validators in the chain specification, block finalization starts after the second node has added its keys. Verify that your keys are in the keystore for node02 by running the following command: bash ls /tmp/node02/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 6772616e1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Substrate nodes require a restart after inserting a grandpa key, so you must shut down and restart nodes before you see blocks being finalized. Shut down the node by pressing Control-c. Restart the second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... After both nodes have added their keys to their respective keystores and been restarted, you should see the same genesis block and state root hashes. You should also see that each node has one peer ( 1 peers ), and they have produced a block proposal ( best: #2 (0xe111\u2026c084) ). After a few seconds, you should see new blocks being finalized. ```bash ```","title":"Enable other participants to join"},{"location":"tutorials/full-private-network-post-edit/#next-steps","text":"You have now seen how you can start a private blockchain with trusted participants. In this tutorial you learned: How to start and stop peer blockchain nodes. How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification. To learn more about the topics introduced in this tutorial, see the following sections: Executor for more information about the WebAssembly runtime that is a core component of the chain specification. Accounts and Key management for more information about key generation and storage options. Cryptography for more information about the signature schemes used for different keys.","title":"Next steps"},{"location":"tutorials/simulate-two-node-network/","text":"This tutorial provides a basic introduction to how to start a private blockchain network with an authority set of private validators . The Substrate node template uses an authority consensus model that limits block production to a rotating list of authorized accounts. The authorized accounts\u2014 authorities \u2014are responsible for creating blocks in a round robin fashion. In this tutorial, you'll see how the authority consensus model works in practice by using two predefined accounts as the authorities that enable the nodes to produce blocks. In this simulated network, the two nodes are started using different accounts and keys but run on a single computer. Before you begin Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Build a local blockchain and have the Substrate node template installed locally. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms. Tutorial objectives By completing this tutorial, you will accomplish the following objectives: Start a blockchain node using using a predefined account. Learn the key command-line options used to start a node. Determine if a node is running and producing blocks. Connect a second node to a running network. Verify peer computers produce and finalize blocks. Start the first blockchain node Before you generate keys to start your own private Substrate network, you can learn the fundamental principles using a predefined network specification called local and running under predefined user accounts. This tutorial simulates a private network by running two Substrate nodes on a single local computer using predefined accounts that are named alice and bob . To start the blockchain: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: ./target/release/node-template purge-chain --base-path /tmp/alice --chain local The command prompts you to confirm the operation: bash Are you sure to remove \"/tmp/alice/chains/local_testnet/db\"? [y/N]: Type y to confirm that you want to remove the chain data. You should always remove old chain data when starting a new network. Start the local blockchain node using the alice account by running the following command: ./target/release/node-template \\ --base-path /tmp/alice \\ --chain local \\ --alice \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --node-key 0000000000000000000000000000000000000000000000000000000000000001 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator Review the command-line options Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain local Specifies the chain specification to use. Valid predefined chain specifications include local , development , and staging . --alice Adds the predefined keys for the alice account to the node's keystore. With this setting, the alice account is used for block production and finalization. --port 30333 Specifies the port to listen on for peer-to-peer ( p2p ) traffic. Because this tutorial uses two nodes running on the same physical computer to simulate a network, you must explicitly specify a different port for at least one account. --ws-port 9945 Specifies the port to listen on for incoming WebSocket traffic. The default port is 9944 . This tutorial uses a custom web socket port number ( 9945 ). --rpc-port 9933 Specifies the port to listen on for incoming RPC traffic. The default port is 9933 . --node-key <key> Specifies the Ed25519 secret key to use for libp2p networking. You should only use this option for development and testing. --telemetry-url Specifies where to send telemetry data. For this tutorial, you can send telemetry data to a server hosted by Parity that is available for anyone to use. --validator Specifies that this node participates in block production and finalization for the network. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help Review the node messages displayed If the node starts successfully, the terminal displays messages describing network operations. For example, you should see output similar to this: 2021-03-10 17:34:27 Substrate Node 2021-03-10 17:34:27 \u270c\ufe0f version 3.0.0-1c5b984-x86_64-linux-gnu 2021-03-10 17:34:27 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-10 17:34:27 \ud83d\udccb Chain specification: Local Testnet 2021-03-10 17:34:27 \ud83c\udff7 Node name: Alice 2021-03-10 17:34:27 \ud83d\udc64 Role: AUTHORITY 2021-03-10 17:34:27 \ud83d\udcbe Database: RocksDb at /tmp/alice/chains/local_testnet/db 2021-03-10 17:34:27 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-10 17:34:27 \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) 2021-03-10 17:34:27 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-10 17:34:27 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-10 17:34:27 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-10 17:34:27 \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:34:27 \ud83d\udce6 Highest known block at #0 2021-03-10 17:34:27 \u303d\ufe0f Prometheus server started at 127.0.0.1:9615 2021-03-10 17:34:27 Listening for new connections on 127.0.0.1:9945. 2021-03-10 17:34:32 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 ... In particular, you should note the following messages in the output: \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) identifies the initial or genesis block that the node is using. When you start the next node, verify that these values are the same. \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp specifies a string that uniquely identifies this node. This string is determined by the --node-key that was used to start the node using the alice account. You use this string to identify the node to connect to when you start a second node. 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 indicates that there are no other nodes in the network and that no blocks are being produced. Another node must join the network before blocks can start to be produced. Add a second node to the blockchain network Now that the node you started using the alice account keys is running, you can add another node to the network using the bob account. Because you are joining a network that is already running, you can use the running node to identify the network for the new node to join. The commands are similar to the ones you used before, but with a few important differences. To add a node to the running blockchain: Open a new terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: ./target/release/node-template purge-chain --base-path /tmp/bob --chain local -y By adding -y to the command, you can remove chain data without being prompted you to confirm the operation. Start a second local blockchain node using the bob account by running the following command: ./target/release/node-template \\ --base-path /tmp/bob \\ --chain local \\ --bob \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp Note the following differences between this command and the previous one: Because the two nodes are running on the same physical computer, you must specify different values for the --base-path , --port , --ws-port , and --rpc-port options. This command includes the --bootnodes option and specifies a single boot node, the node started by alice . The --bootnodes option specifies the following information: ip4 indicates that the IP address for the node uses the IPv4 format 127.0.0.1 specifies the IP address for the running node. In this case, the address for the localhost . tcp specifies TCP as the protocol used for peer-to-peer communication. 30333 specifies the port number used for peer-to-peer communication. In this case, the port number for TCP traffic. 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp identifies the running node to communicate with for this network. In this case, the identifier for the node started using the alice account. Verify blocks are produced and finalized After you start the second node, the nodes should connect to each other as peers and start producing blocks. To verify blocks are being finalized: Verify that you see lines similar to the following in the terminal where you started the first node: bash 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/<your-computer-LAN-IP>/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:33 \ud83d\udca4 Idle (1 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 1.0kiB/s \u2b06 1.0kiB/s 2021-03-10 17:47:36 \ud83d\ude4c Starting consensus session on top of parent 0x9d07d1757a9ca248e58141ce52a11fca37f71007dec16650b87a853f0d4c7cce 2021-03-10 17:47:36 \ud83c\udf81 Prepared block for proposing at 1 [hash: 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f; parent_hash: 0x9d07\u20267cce; extrinsics (1): [0x768a\u2026a9e2]] 2021-03-10 17:47:36 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x4841d8b2e62483fa4702b3ddcd1b603803842374dcdc1e9533ad407708b33dd8, previously 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f. 2021-03-10 17:47:36 \u2728 Imported #1 (0x4841\u20263dd8) 2021-03-10 17:47:36 \u2728 Imported #1 (0xb241\u20262ae8) 2021-03-10 17:47:38 \ud83d\udca4 Idle (1 peers), best: #1 (0x4841\u20263dd8), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:42 \u267b\ufe0f Reorg on #1,0x4841\u20263dd8 to #2,0x8b6a\u2026dce6, common ancestor #0,0x9d07\u20267cce 2021-03-10 17:47:42 \u2728 Imported #2 (0x8b6a\u2026dce6) 2021-03-10 17:47:43 \ud83d\udca4 Idle (1 peers), best: #2 (0x8b6a\u2026dce6), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:48 \ud83d\ude4c Starting consensus session on top of parent 0x8b6a3ab2fe9891b1af008ea0d92dae9bc84cfa5578231e81066d47928822dce6 2021-03-10 17:47:48 \ud83c\udf81 Prepared block for proposing at 3 [hash: 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a; parent_hash: 0x8b6a\u2026dce6; extrinsics (1): [0x82ac\u20262f20]] 2021-03-10 17:47:48 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x34d608dd8be6b82bef4a7aaae1ec80930a5c4b8cf9bdc99013410e91544f3a2a, previously 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a. 2021-03-10 17:47:48 \u2728 Imported #3 (0x34d6\u20263a2a) 2021-03-10 17:47:48 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #0 (0x9d07\u20267cce), \u2b07 0.7kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:53 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #1 (0xb241\u20262ae8), \u2b07 0.6kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:54 \u2728 Imported #4 (0x2b8a\u2026fdc4) 2021-03-10 17:47:58 \ud83d\udca4 Idle (1 peers), best: #4 (0x2b8a\u2026fdc4), finalized #2 (0x8b6a\u2026dce6), \u2b07 0.7kiB/s \u2b06 0.6kiB/s ... In these lines, you can see the following information aout your blockchain: The first node was started by alice . The node has a one peer ( 1 peers ). The nodes have produced some blocks ( best: #4 (0x2b8a\u2026fdc4) ). The blocks are being finalized ( finalized #2 (0x8b6a\u2026dce6) ). Verify that you see similar output in the terminal where you started the second node. Shut down both nodes by pressing Control-c in each terminal shell. Next steps This tutorial introduced the first basic steps for starting a private blockchain network. In this tutorial, you simulated the private network by running two nodes on a single computer and using predefined accounts as participants. You learned: How to use several of the node template commands and command-line options. How to start two blockchain nodes that communicate with each other as peers. How to verify your private blockchain nodes are producing blocks. The next tutorial builds on the information you learned in this tutorial to illustrate how you can start a private network with other participants and nodes running on separate computers. In Start a private network , you'll learn: How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification.","title":"Simulate a network"},{"location":"tutorials/simulate-two-node-network/#before-you-begin","text":"Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Build a local blockchain and have the Substrate node template installed locally. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms.","title":"Before you begin"},{"location":"tutorials/simulate-two-node-network/#tutorial-objectives","text":"By completing this tutorial, you will accomplish the following objectives: Start a blockchain node using using a predefined account. Learn the key command-line options used to start a node. Determine if a node is running and producing blocks. Connect a second node to a running network. Verify peer computers produce and finalize blocks.","title":"Tutorial objectives"},{"location":"tutorials/simulate-two-node-network/#start-the-first-blockchain-node","text":"Before you generate keys to start your own private Substrate network, you can learn the fundamental principles using a predefined network specification called local and running under predefined user accounts. This tutorial simulates a private network by running two Substrate nodes on a single local computer using predefined accounts that are named alice and bob . To start the blockchain: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: ./target/release/node-template purge-chain --base-path /tmp/alice --chain local The command prompts you to confirm the operation: bash Are you sure to remove \"/tmp/alice/chains/local_testnet/db\"? [y/N]: Type y to confirm that you want to remove the chain data. You should always remove old chain data when starting a new network. Start the local blockchain node using the alice account by running the following command: ./target/release/node-template \\ --base-path /tmp/alice \\ --chain local \\ --alice \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --node-key 0000000000000000000000000000000000000000000000000000000000000001 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator","title":"Start the first blockchain node"},{"location":"tutorials/simulate-two-node-network/#review-the-command-line-options","text":"Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain local Specifies the chain specification to use. Valid predefined chain specifications include local , development , and staging . --alice Adds the predefined keys for the alice account to the node's keystore. With this setting, the alice account is used for block production and finalization. --port 30333 Specifies the port to listen on for peer-to-peer ( p2p ) traffic. Because this tutorial uses two nodes running on the same physical computer to simulate a network, you must explicitly specify a different port for at least one account. --ws-port 9945 Specifies the port to listen on for incoming WebSocket traffic. The default port is 9944 . This tutorial uses a custom web socket port number ( 9945 ). --rpc-port 9933 Specifies the port to listen on for incoming RPC traffic. The default port is 9933 . --node-key <key> Specifies the Ed25519 secret key to use for libp2p networking. You should only use this option for development and testing. --telemetry-url Specifies where to send telemetry data. For this tutorial, you can send telemetry data to a server hosted by Parity that is available for anyone to use. --validator Specifies that this node participates in block production and finalization for the network. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help","title":"Review the command-line options"},{"location":"tutorials/simulate-two-node-network/#review-the-node-messages-displayed","text":"If the node starts successfully, the terminal displays messages describing network operations. For example, you should see output similar to this: 2021-03-10 17:34:27 Substrate Node 2021-03-10 17:34:27 \u270c\ufe0f version 3.0.0-1c5b984-x86_64-linux-gnu 2021-03-10 17:34:27 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-03-10 17:34:27 \ud83d\udccb Chain specification: Local Testnet 2021-03-10 17:34:27 \ud83c\udff7 Node name: Alice 2021-03-10 17:34:27 \ud83d\udc64 Role: AUTHORITY 2021-03-10 17:34:27 \ud83d\udcbe Database: RocksDb at /tmp/alice/chains/local_testnet/db 2021-03-10 17:34:27 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-03-10 17:34:27 \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) 2021-03-10 17:34:27 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-03-10 17:34:27 \u23f1 Loaded block-time = 6000 milliseconds from genesis on first-launch 2021-03-10 17:34:27 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-03-10 17:34:27 \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:34:27 \ud83d\udce6 Highest known block at #0 2021-03-10 17:34:27 \u303d\ufe0f Prometheus server started at 127.0.0.1:9615 2021-03-10 17:34:27 Listening for new connections on 127.0.0.1:9945. 2021-03-10 17:34:32 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 ... In particular, you should note the following messages in the output: \ud83d\udd28 Initializing Genesis block/state (state: 0xea47\u20269ba8, header-hash: 0x9d07\u20267cce) identifies the initial or genesis block that the node is using. When you start the next node, verify that these values are the same. \ud83c\udff7 Local node identity is: 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp specifies a string that uniquely identifies this node. This string is determined by the --node-key that was used to start the node using the alice account. You use this string to identify the node to connect to when you start a second node. 2021-03-10 17:34:37 \ud83d\udca4 Idle (0 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 0 \u2b06 0 indicates that there are no other nodes in the network and that no blocks are being produced. Another node must join the network before blocks can start to be produced.","title":"Review the node messages displayed"},{"location":"tutorials/simulate-two-node-network/#add-a-second-node-to-the-blockchain-network","text":"Now that the node you started using the alice account keys is running, you can add another node to the network using the bob account. Because you are joining a network that is already running, you can use the running node to identify the network for the new node to join. The commands are similar to the ones you used before, but with a few important differences. To add a node to the running blockchain: Open a new terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data by running the following command: ./target/release/node-template purge-chain --base-path /tmp/bob --chain local -y By adding -y to the command, you can remove chain data without being prompted you to confirm the operation. Start a second local blockchain node using the bob account by running the following command: ./target/release/node-template \\ --base-path /tmp/bob \\ --chain local \\ --bob \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp Note the following differences between this command and the previous one: Because the two nodes are running on the same physical computer, you must specify different values for the --base-path , --port , --ws-port , and --rpc-port options. This command includes the --bootnodes option and specifies a single boot node, the node started by alice . The --bootnodes option specifies the following information: ip4 indicates that the IP address for the node uses the IPv4 format 127.0.0.1 specifies the IP address for the running node. In this case, the address for the localhost . tcp specifies TCP as the protocol used for peer-to-peer communication. 30333 specifies the port number used for peer-to-peer communication. In this case, the port number for TCP traffic. 12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp identifies the running node to communicate with for this network. In this case, the identifier for the node started using the alice account.","title":"Add a second node to the blockchain network"},{"location":"tutorials/simulate-two-node-network/#verify-blocks-are-produced-and-finalized","text":"After you start the second node, the nodes should connect to each other as peers and start producing blocks. To verify blocks are being finalized: Verify that you see lines similar to the following in the terminal where you started the first node: bash 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:32 \ud83d\udd0d Discovered new external address for our node: /ip4/<your-computer-LAN-IP>/tcp/30333/p2p/12D3KooWEyoppNCUx8Yx66oV9fJnriXwCcXwDDUA2kj6vnc6iDEp 2021-03-10 17:47:33 \ud83d\udca4 Idle (1 peers), best: #0 (0x9d07\u20267cce), finalized #0 (0x9d07\u20267cce), \u2b07 1.0kiB/s \u2b06 1.0kiB/s 2021-03-10 17:47:36 \ud83d\ude4c Starting consensus session on top of parent 0x9d07d1757a9ca248e58141ce52a11fca37f71007dec16650b87a853f0d4c7cce 2021-03-10 17:47:36 \ud83c\udf81 Prepared block for proposing at 1 [hash: 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f; parent_hash: 0x9d07\u20267cce; extrinsics (1): [0x768a\u2026a9e2]] 2021-03-10 17:47:36 \ud83d\udd16 Pre-sealed block for proposal at 1. Hash now 0x4841d8b2e62483fa4702b3ddcd1b603803842374dcdc1e9533ad407708b33dd8, previously 0x727826a5e6fba9a13af11422d4677b5f0743cc733c382232328e69fd307d1d2f. 2021-03-10 17:47:36 \u2728 Imported #1 (0x4841\u20263dd8) 2021-03-10 17:47:36 \u2728 Imported #1 (0xb241\u20262ae8) 2021-03-10 17:47:38 \ud83d\udca4 Idle (1 peers), best: #1 (0x4841\u20263dd8), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:42 \u267b\ufe0f Reorg on #1,0x4841\u20263dd8 to #2,0x8b6a\u2026dce6, common ancestor #0,0x9d07\u20267cce 2021-03-10 17:47:42 \u2728 Imported #2 (0x8b6a\u2026dce6) 2021-03-10 17:47:43 \ud83d\udca4 Idle (1 peers), best: #2 (0x8b6a\u2026dce6), finalized #0 (0x9d07\u20267cce), \u2b07 0.8kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:48 \ud83d\ude4c Starting consensus session on top of parent 0x8b6a3ab2fe9891b1af008ea0d92dae9bc84cfa5578231e81066d47928822dce6 2021-03-10 17:47:48 \ud83c\udf81 Prepared block for proposing at 3 [hash: 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a; parent_hash: 0x8b6a\u2026dce6; extrinsics (1): [0x82ac\u20262f20]] 2021-03-10 17:47:48 \ud83d\udd16 Pre-sealed block for proposal at 3. Hash now 0x34d608dd8be6b82bef4a7aaae1ec80930a5c4b8cf9bdc99013410e91544f3a2a, previously 0xb887aef2097eff5869e38ccec0302bce372ad05ac2cdf9cc4725c38ec071fb7a. 2021-03-10 17:47:48 \u2728 Imported #3 (0x34d6\u20263a2a) 2021-03-10 17:47:48 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #0 (0x9d07\u20267cce), \u2b07 0.7kiB/s \u2b06 0.8kiB/s 2021-03-10 17:47:53 \ud83d\udca4 Idle (1 peers), best: #3 (0x34d6\u20263a2a), finalized #1 (0xb241\u20262ae8), \u2b07 0.6kiB/s \u2b06 0.7kiB/s 2021-03-10 17:47:54 \u2728 Imported #4 (0x2b8a\u2026fdc4) 2021-03-10 17:47:58 \ud83d\udca4 Idle (1 peers), best: #4 (0x2b8a\u2026fdc4), finalized #2 (0x8b6a\u2026dce6), \u2b07 0.7kiB/s \u2b06 0.6kiB/s ... In these lines, you can see the following information aout your blockchain: The first node was started by alice . The node has a one peer ( 1 peers ). The nodes have produced some blocks ( best: #4 (0x2b8a\u2026fdc4) ). The blocks are being finalized ( finalized #2 (0x8b6a\u2026dce6) ). Verify that you see similar output in the terminal where you started the second node. Shut down both nodes by pressing Control-c in each terminal shell.","title":"Verify blocks are produced and finalized"},{"location":"tutorials/simulate-two-node-network/#next-steps","text":"This tutorial introduced the first basic steps for starting a private blockchain network. In this tutorial, you simulated the private network by running two nodes on a single computer and using predefined accounts as participants. You learned: How to use several of the node template commands and command-line options. How to start two blockchain nodes that communicate with each other as peers. How to verify your private blockchain nodes are producing blocks. The next tutorial builds on the information you learned in this tutorial to illustrate how you can start a private network with other participants and nodes running on separate computers. In Start a private network , you'll learn: How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification.","title":"Next steps"},{"location":"tutorials/start-a-private-network/","text":"This tutorial illustrates how you can start a small, standalone blockchain network with an authority set of private validators . As you learned in Blockchain basics , all blockchains require the nodes in the network to agree on the state of data at any specific point in time and this agreement about the state is called consensus . The Substrate node template uses a proof of authority consensus model also referred to as authority round or Aura consensus. The Aura consensus protocol limits block production to a rotating list of authorized accounts. The authorized accounts\u2014 authorities \u2014create blocks in a round robin fashion and are generally considered to be trusted participants in the network. This consensus model provides a simple approach to starting a solo blockchain for a limited number of participants. In this tutorial, you'll see how to generate the keys required to authorize a node to participate in the network, how to configure and share information about the network with other authorized accounts, and how to launch the network with an approved set of validators. Before you begin Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Build a local blockchain and have the Substrate node template installed locally. You have used predefined accounts as described in Simulate a private two-node network to start nodes on a single computer. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms. Tutorial objectives By completing this tutorial, you will accomplish the following objectives: Generate key pairs for use as a network authority. Create a custom chain specification file. Launch a private two-node blockchain network. Generate your account and keys Now that you know how to start and connect running nodes as peers using command-line options, you are ready to generate your own secret keys instead of using the predefined account keys. It's important to remember that each participant in the blockchain network is responsible for generating unique keys. Key generation options There are several ways you can generate keys. For example, you can generate key pairs using a node-template subcommand, the standalone Subkey command-line program, the Polkadot-JS application, or third-party key generation utilities. Although you could use predefined key pairs to complete this tutorial, you would never use those keys in a production environment. Instead of using predefined keys or the more secure subkey program, this tutorial illustrates how to generate keys using the Substrate node template and the key subcommand. Generate local keys using the node template You have already used the some command-line options to start your local blockchain node using the predefined alice and bob accounts. You can also use command-line options to generate random keys to use with Substrate. For this tutorial, you can remain connected to the internet and use your local node to generate your keys. As a best practice, you should use an air-gapped computer that has never been connected to the internet when you generate keys for a production blockchain. At a minimum, you should disconnect from the internet before you generate any keys you intend to use on a public or private blockchain that is not under your control. To generate keys using the node template: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Generate a random secret phrase and keys by running the following command: ./target/release/node-template key generate --scheme Sr25519 --password-interactive Type a password for the generated keys. The command generates keys and displays output similar to the following: Secret phrase: pig giraffe ceiling enter weird liar orange decline behind total despair fly Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Account ID: 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW SS58 Address: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW Use the secret seed for the account you generated to derive keys using the Ed25519 signature scheme by running the following command: ./target/release/node-template key inspect \\ --password-interactive --scheme Ed25519 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Type the password you used to the generated keys. The command displays output similar to the following: Secret Key URI 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f is account: Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Account ID: 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN SS58 Address: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN You now have the Sr25519 key for producing blocks using aura and the Ed25519 key for finalizing blocks using grandpa for one node. 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW for aura . 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN for grandpa . Generate or collect additional accounts and keys You can repeat the steps to generate a second key pair on another computer or you can recruit other participants to generate the accounts and keys required to join your private network. For this tutorial, the private network consists of just two nodes, so you need two sets of keys. For illustration purposes, the second set of keys used in this tutorial are: 5CXGP4oPXC1Je3zf5wEDkYeAqGcGXyKWSRX2Jm14GdME5Xc5 for aura . 5DpdMN4bVTMy67TfMMtinQTcUmLhZBWoWarHvEYPM4jYziqm for grandpa . If you recruit other participants to join your network, be sure to collect the Sr25519 key for producing blocks using aura and the Ed25519 key for finalizing blocks using grandpa for each participant you plan to authorize as a validator before continuing to the next step. Create a custom chain specification After you generate and collect the keys to use with your blockchain, you are ready to create a custom chain specification using those key then share your custom chain specification with trusted network participants that you are authorizing as validators. To enable others to participate in your blockchain network, you should ensure that they generate their own keys. If other participants have generated their key pairs, you can create a custom chain specification to replace the local chain specification that you used previously. For simplicity, the custom chain specification you create in this tutorial is a modified version of the local chain specification that illustrates how to create a two-node network. You can follow the same steps to add more nodes to the network if you have the required keys. Modify the local chain specification Instead of writing a completely new chain specification, you can modify the predefined local chain specification. To create a new chain specification based on the local specification: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Export the local chain specification to a file named customSpec.json by running the following command: bash ./target/release/node-template build-spec --disable-default-bootnode --chain local > customSpec.json If you open the customSpec.json file in a text editor, you would see that it contains several fields, including a large blob that contains the WebAssembly (Wasm) binary for the runtime you built using the cargo build --release command. Instead of viewing the entire file, you can preview the first and last few lines to see the fields you need to change. Preview the first few fields in the customSpec.json file by running the following command: bash head customSpec.json The command displays the first fields from the file. For example: bash { \"name\": \"Local Testnet\", \"id\": \"local_testnet\", \"chainType\": \"Local\", \"bootNodes\": [], \"telemetryEndpoints\": null, \"protocolId\": null, \"properties\": null, \"consensusEngine\": null, \"codeSubstitutes\": {}, Preview the last fields in the customSpec.json file by running the following command: bash tail -n 80 customSpec.json This command displays the last sections following the Wasm binary field, including the details for several of the pallets\u2014such as the sudo and balances pallets\u2014that are used in the runtime. Open the customSpec.json file in a text editor. Modify the name field to identify this chain specification as a custom chain specification. For example: json \"name\": \"My Custom Testnet\", Modify aura field to specify the nodes with the authority to create blocks by adding the Sr25519 SS58 address keys for each network participant. json \"aura\": { \"authorities\": [ \"5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW\", \"5CXGP4oPXC1Je3zf5wEDkYeAqGcGXyKWSRX2Jm14GdME5Xc5\" ] }, Modify the grandpa field to specify the nodes with the authority to finalize blocks by adding the Ed25519 SS58 address keys for each network participant. json \"grandpa\": { \"authorities\": [ [ \"5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN\", 1 ], [ \"5DpdMN4bVTMy67TfMMtinQTcUmLhZBWoWarHvEYPM4jYziqm\", 1 ] ] }, Note that there are two data values for the authorities field in the grandpa section. The first value is the address key. The second value is used to support weighted votes . In this example, each validator has a weight of 1 vote. Save your changes and close the file. Add validators As you have just seen, you can add and change the authority addresses in a chain specification by modifying the aura and grandpa sections. You can use this technique to add as many validators as you like. To add validators: Modify the aura section to include Sr25519 addresses. Modify the grandpa section to include Ed25519 addresses and a voting weight. Be sure to use unique keys for each validator. If two validators have the same keys, they produce conflicting blocks. For additional information about working with key pairs and signatures, see Public-Key cryptography . Convert the chain specification to use the raw format After you prepare a chain specification with the information you want to use, you must convert it into a raw specification before it can be used. The raw chain specification includes the same information as the unconverted specification. However, the raw chain specification also contains encoded storage keys that the node uses to reference the data in its local storage. Distributing a raw chain specification ensures that each node stores the data using the proper storage keys. To convert a chain specification to use the raw format: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Convert the customSpec.json chain specification to the raw format with the file name customSpecRaw.json by running the following command: bash ./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode > customSpecRaw.json Share the chain specification with others If you are creating a private blockchain network to share with other participants, ensure that only one person creates the chain specifiction and shares the resulting raw version of that specification\u2014for example, the customSpecRaw.json file\u2014with all of the other validators in the network. Because the Rust compiler produces optimized WebAssembly binaries that aren't deterministically reproducible, each person who generates the Wasm runtime produces a slightly different Wasm blob. To ensure determinism, all participants in the blockchain network must use exactly the same raw chain specification file. For more information about this issue, see Hunting down a non-determinism-bug in our Rust Wasm build . Prepare to launch the private network After you distribute the custom chain specification to all network participants, you're ready to launch your own private blockchain. The steps are similar to the steps you followed in Start the blockchain using predefined accounts . To continue with this part of the tutorial, you are no longer using a single physical computer or a single binary. To continue, verify the following: You have generated or collected the account keys for at least two authority accounts. You have updated your custom chain specification to include the keys for block production ( aura ) and block finalization ( grandpa ). You have converted your custom chain specification to raw format and distributed the raw chain specification to the nodes participating in the private network. If you have completed these steps, you are ready to start the first node in the private blockchain. Start the first blockchain node As the first participant in the private blockchain network, you are responsible for starting the first node, called the bootnode . To start the first node: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node01 --chain local -y Start the first node using the custom chain specification by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node01 \\ --chain ./customSpecRaw.json \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode01 Note the following changes to the command you are running to start the node: Instead of the predefined --alice account, you are using your own keys. You'll add your keys to the keystore in a separate step. The --chain command-line option specifies the custom chain specification. The --name command-line option enables you to give your node a human-readable name in the telemetry UI. The --rpc-methods Unsafe command-line option allows you to continue the tutorial using an unsafe communication mode because your blockchain is not being used in a production setting. Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain Specifies the custom chain specification to use. --port | Specifies the port to listen on for peer-to-peer ( p2p`) traffic. --ws-port Specifies the port to listen on for incoming WebSocket traffic. --rpc-port Specifies the port to listen on for incoming RPC traffic. --telemetry-url Specifies where to send telemetry data. --validator Specifies that this node participates in block production and finalization for the network. --rpc-methods Specifies the RPC methods to allow. The Unsafe setting allows unsafe communication methods because this blockchain is not being used in a production setting. --name Specifies a human-readable name for the node that you can view in the telemetry user interface. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help Verify that you see output similar to the following: bash 2021-11-03 15:32:14 Substrate Node 2021-11-03 15:32:14 \u270c\ufe0f version 3.0.0-monthly-2021-09+1-bf52814-x86_64-macos 2021-11-03 15:32:14 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-11-03 15:32:14 \ud83d\udccb Chain specification: My Custom Testnet 2021-11-03 15:32:14 \ud83c\udff7 Node name: MyNode01 2021-11-03 15:32:14 \ud83d\udc64 Role: AUTHORITY 2021-11-03 15:32:14 \ud83d\udcbe Database: RocksDb at /tmp/node01/chains/local_testnet/db 2021-11-03 15:32:14 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-11-03 15:32:15 \ud83d\udd28 Initializing Genesis block/state (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) 2021-11-03 15:32:15 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-11-03 15:32:15 \u23f1 Loaded block-time = 6s from block 0x6c78abc724f83285d1487ddcb1f948a2773cb38219c4674f84c727833be737de 2021-11-03 15:32:15 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-11-03 15:32:15 \ud83c\udff7 Local node identity is: 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX 2021-11-03 15:32:15 \ud83d\udce6 Highest known block at #0 2021-11-03 15:32:15 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2021-11-03 15:32:15 Listening for new connections on 127.0.0.1:9945. 2021-11-03 15:32:20 \ud83d\udca4 Idle (0 peers), best: #0 (0x6c78\u202637de), finalized #0 (0x6c78\u202637de), \u2b07 0 \u2b06 0 In the output, take note of the following information: The initial or genesis block that the node is using is (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) . When you start the next node, verify that these values are the same. The node identity is 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX . The IP address is 127.0.0.1 . The peer-to-peer (p2p) port is --port = 30333 . These values are for this specific tutorial example. The values will be different for your node and you must provide the values for your node to other network participants to connect to the bootnode. Add keys to the keystore After you start the first node, no blocks are yet produced. The next step is to add two types of keys to the keystore for each node in the network. For each node: Add the aura authority keys to enable block production . Add the grandpa authority keys to enable block finalization . There are several ways you can insert keys into the keystore. For this tutorial, you can use the key subcommand to insert locally-generated secret keys. To insert keys into the keystore: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Insert the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 \\ --password-interactive \\ --key-type aura This example uses the secret seed generated from the key subcommand into the keystore. You can also insert a key from a specified file location. For information about the command-line option available, run the following command: bash ./target/release/node-template key insert --help Insert the grandpa secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 \\ --password-interactive \\ --key-type gran Verify that your keys are in the keystore for node01 by running the following command: bash ls /tmp/node01/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 6772616e1441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 Enable other participants to join You can now allow other validators to join the network using the --bootnodes and --validator command-line options. To add a second validator to the private network: Open a terminal shell on a second computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node02 --chain local -y Start a second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Add the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f \\ --password-interactive \\ --key-type aura Note that this command uses the second participant's secret key and that the aura key type is required to enable block production. Add the grandpa secret key generated from the key subcommand to the local keystore by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f \\ --password-interactive \\ --key-type gran Note that this command uses the second participant's secret key and that the gran key type is required to enable block finalization. Block finalization requires at least two-thirds of the validators to add their keys to their respective keystores. Because this network is configured with two validators in the chain specification, block finalization starts after the second node has added its keys. Verify that your keys are in the keystore for node02 by running the following command: bash ls /tmp/node02/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 6772616e1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Substrate nodes require a restart after inserting a grandpa key, so you must shut down and restart nodes before you see blocks being finalized. Shut down the node by pressing Control-c. Restart the second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url 'wss://telemetry.polkadot.io/submit/ 0' \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... After both nodes have added their keys to their respective keystores and been restarted, you should see the same genesis block and state root hashes. You should also see that each node has one peer ( 1 peers ), and they have produced a block proposal ( best: #2 (0xe111\u2026c084) ). After a few seconds, you should see new blocks being finalized. ```bash ``` Next steps You have now seen how you can start a private blockchain with trusted participants. In this tutorial you learned: How to start and stop peer blockchain nodes. How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification. To learn more about the topics introduced in this tutorial, see the following sections: Executor for more information about the WebAssembly runtime that is a core component of the chain specification. Accounts and Key management for more information about key generation and storage options. Cryptography for more information about the signature schemes used for different keys.","title":"Start a private network"},{"location":"tutorials/start-a-private-network/#before-you-begin","text":"Before you begin, verify the following: You have configured your environment for Substrate development by installing Rust and the Rust toolchain . You have completed Build a local blockchain and have the Substrate node template installed locally. You have used predefined accounts as described in Simulate a private two-node network to start nodes on a single computer. You are generally familiar with software development and using command-line interfaces. You are generally familiar with blockchains and smart contract platforms.","title":"Before you begin"},{"location":"tutorials/start-a-private-network/#tutorial-objectives","text":"By completing this tutorial, you will accomplish the following objectives: Generate key pairs for use as a network authority. Create a custom chain specification file. Launch a private two-node blockchain network.","title":"Tutorial objectives"},{"location":"tutorials/start-a-private-network/#generate-your-account-and-keys","text":"Now that you know how to start and connect running nodes as peers using command-line options, you are ready to generate your own secret keys instead of using the predefined account keys. It's important to remember that each participant in the blockchain network is responsible for generating unique keys.","title":"Generate your account and keys"},{"location":"tutorials/start-a-private-network/#key-generation-options","text":"There are several ways you can generate keys. For example, you can generate key pairs using a node-template subcommand, the standalone Subkey command-line program, the Polkadot-JS application, or third-party key generation utilities. Although you could use predefined key pairs to complete this tutorial, you would never use those keys in a production environment. Instead of using predefined keys or the more secure subkey program, this tutorial illustrates how to generate keys using the Substrate node template and the key subcommand.","title":"Key generation options"},{"location":"tutorials/start-a-private-network/#generate-local-keys-using-the-node-template","text":"You have already used the some command-line options to start your local blockchain node using the predefined alice and bob accounts. You can also use command-line options to generate random keys to use with Substrate. For this tutorial, you can remain connected to the internet and use your local node to generate your keys. As a best practice, you should use an air-gapped computer that has never been connected to the internet when you generate keys for a production blockchain. At a minimum, you should disconnect from the internet before you generate any keys you intend to use on a public or private blockchain that is not under your control. To generate keys using the node template: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Generate a random secret phrase and keys by running the following command: ./target/release/node-template key generate --scheme Sr25519 --password-interactive Type a password for the generated keys. The command generates keys and displays output similar to the following: Secret phrase: pig giraffe ceiling enter weird liar orange decline behind total despair fly Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Account ID: 0x1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Public key (SS58): 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW SS58 Address: 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW Use the secret seed for the account you generated to derive keys using the Ed25519 signature scheme by running the following command: ./target/release/node-template key inspect \\ --password-interactive --scheme Ed25519 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Type the password you used to the generated keys. The command displays output similar to the following: Secret Key URI 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f is account: Secret seed: 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f Public key (hex): 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Account ID: 0x2577ba03f47cdbea161851d737e41200e471cd7a31a5c88242a527837efc1e7b Public key (SS58): 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN SS58 Address: 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN You now have the Sr25519 key for producing blocks using aura and the Ed25519 key for finalizing blocks using grandpa for one node. 5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW for aura . 5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN for grandpa .","title":"Generate local keys using the node template"},{"location":"tutorials/start-a-private-network/#generate-or-collect-additional-accounts-and-keys","text":"You can repeat the steps to generate a second key pair on another computer or you can recruit other participants to generate the accounts and keys required to join your private network. For this tutorial, the private network consists of just two nodes, so you need two sets of keys. For illustration purposes, the second set of keys used in this tutorial are: 5CXGP4oPXC1Je3zf5wEDkYeAqGcGXyKWSRX2Jm14GdME5Xc5 for aura . 5DpdMN4bVTMy67TfMMtinQTcUmLhZBWoWarHvEYPM4jYziqm for grandpa . If you recruit other participants to join your network, be sure to collect the Sr25519 key for producing blocks using aura and the Ed25519 key for finalizing blocks using grandpa for each participant you plan to authorize as a validator before continuing to the next step.","title":"Generate or collect additional accounts and keys"},{"location":"tutorials/start-a-private-network/#create-a-custom-chain-specification","text":"After you generate and collect the keys to use with your blockchain, you are ready to create a custom chain specification using those key then share your custom chain specification with trusted network participants that you are authorizing as validators. To enable others to participate in your blockchain network, you should ensure that they generate their own keys. If other participants have generated their key pairs, you can create a custom chain specification to replace the local chain specification that you used previously. For simplicity, the custom chain specification you create in this tutorial is a modified version of the local chain specification that illustrates how to create a two-node network. You can follow the same steps to add more nodes to the network if you have the required keys.","title":"Create a custom chain specification"},{"location":"tutorials/start-a-private-network/#modify-the-local-chain-specification","text":"Instead of writing a completely new chain specification, you can modify the predefined local chain specification. To create a new chain specification based on the local specification: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Export the local chain specification to a file named customSpec.json by running the following command: bash ./target/release/node-template build-spec --disable-default-bootnode --chain local > customSpec.json If you open the customSpec.json file in a text editor, you would see that it contains several fields, including a large blob that contains the WebAssembly (Wasm) binary for the runtime you built using the cargo build --release command. Instead of viewing the entire file, you can preview the first and last few lines to see the fields you need to change. Preview the first few fields in the customSpec.json file by running the following command: bash head customSpec.json The command displays the first fields from the file. For example: bash { \"name\": \"Local Testnet\", \"id\": \"local_testnet\", \"chainType\": \"Local\", \"bootNodes\": [], \"telemetryEndpoints\": null, \"protocolId\": null, \"properties\": null, \"consensusEngine\": null, \"codeSubstitutes\": {}, Preview the last fields in the customSpec.json file by running the following command: bash tail -n 80 customSpec.json This command displays the last sections following the Wasm binary field, including the details for several of the pallets\u2014such as the sudo and balances pallets\u2014that are used in the runtime. Open the customSpec.json file in a text editor. Modify the name field to identify this chain specification as a custom chain specification. For example: json \"name\": \"My Custom Testnet\", Modify aura field to specify the nodes with the authority to create blocks by adding the Sr25519 SS58 address keys for each network participant. json \"aura\": { \"authorities\": [ \"5CfBuoHDvZ4fd8jkLQicNL8tgjnK8pVG9AiuJrsNrRAx6CNW\", \"5CXGP4oPXC1Je3zf5wEDkYeAqGcGXyKWSRX2Jm14GdME5Xc5\" ] }, Modify the grandpa field to specify the nodes with the authority to finalize blocks by adding the Ed25519 SS58 address keys for each network participant. json \"grandpa\": { \"authorities\": [ [ \"5CuqCGfwqhjGzSqz5mnq36tMe651mU9Ji8xQ4JRuUTvPcjVN\", 1 ], [ \"5DpdMN4bVTMy67TfMMtinQTcUmLhZBWoWarHvEYPM4jYziqm\", 1 ] ] }, Note that there are two data values for the authorities field in the grandpa section. The first value is the address key. The second value is used to support weighted votes . In this example, each validator has a weight of 1 vote. Save your changes and close the file.","title":"Modify the local chain specification"},{"location":"tutorials/start-a-private-network/#add-validators","text":"As you have just seen, you can add and change the authority addresses in a chain specification by modifying the aura and grandpa sections. You can use this technique to add as many validators as you like. To add validators: Modify the aura section to include Sr25519 addresses. Modify the grandpa section to include Ed25519 addresses and a voting weight. Be sure to use unique keys for each validator. If two validators have the same keys, they produce conflicting blocks. For additional information about working with key pairs and signatures, see Public-Key cryptography .","title":"Add validators"},{"location":"tutorials/start-a-private-network/#convert-the-chain-specification-to-use-the-raw-format","text":"After you prepare a chain specification with the information you want to use, you must convert it into a raw specification before it can be used. The raw chain specification includes the same information as the unconverted specification. However, the raw chain specification also contains encoded storage keys that the node uses to reference the data in its local storage. Distributing a raw chain specification ensures that each node stores the data using the proper storage keys. To convert a chain specification to use the raw format: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Convert the customSpec.json chain specification to the raw format with the file name customSpecRaw.json by running the following command: bash ./target/release/node-template build-spec --chain=customSpec.json --raw --disable-default-bootnode > customSpecRaw.json","title":"Convert the chain specification to use the raw format"},{"location":"tutorials/start-a-private-network/#share-the-chain-specification-with-others","text":"If you are creating a private blockchain network to share with other participants, ensure that only one person creates the chain specifiction and shares the resulting raw version of that specification\u2014for example, the customSpecRaw.json file\u2014with all of the other validators in the network. Because the Rust compiler produces optimized WebAssembly binaries that aren't deterministically reproducible, each person who generates the Wasm runtime produces a slightly different Wasm blob. To ensure determinism, all participants in the blockchain network must use exactly the same raw chain specification file. For more information about this issue, see Hunting down a non-determinism-bug in our Rust Wasm build .","title":"Share the chain specification with others"},{"location":"tutorials/start-a-private-network/#prepare-to-launch-the-private-network","text":"After you distribute the custom chain specification to all network participants, you're ready to launch your own private blockchain. The steps are similar to the steps you followed in Start the blockchain using predefined accounts . To continue with this part of the tutorial, you are no longer using a single physical computer or a single binary. To continue, verify the following: You have generated or collected the account keys for at least two authority accounts. You have updated your custom chain specification to include the keys for block production ( aura ) and block finalization ( grandpa ). You have converted your custom chain specification to raw format and distributed the raw chain specification to the nodes participating in the private network. If you have completed these steps, you are ready to start the first node in the private blockchain.","title":"Prepare to launch the private network"},{"location":"tutorials/start-a-private-network/#start-the-first-blockchain-node","text":"As the first participant in the private blockchain network, you are responsible for starting the first node, called the bootnode . To start the first node: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node01 --chain local -y Start the first node using the custom chain specification by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node01 \\ --chain ./customSpecRaw.json \\ --port 30333 \\ --ws-port 9945 \\ --rpc-port 9933 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode01 Note the following changes to the command you are running to start the node: Instead of the predefined --alice account, you are using your own keys. You'll add your keys to the keystore in a separate step. The --chain command-line option specifies the custom chain specification. The --name command-line option enables you to give your node a human-readable name in the telemetry UI. The --rpc-methods Unsafe command-line option allows you to continue the tutorial using an unsafe communication mode because your blockchain is not being used in a production setting. Before moving on, have a look at how the following options are used to start the node template. : Option : Description --base-path Specifies the directory for storing all of the data related to this chain. --chain Specifies the custom chain specification to use. --port | Specifies the port to listen on for peer-to-peer ( p2p`) traffic. --ws-port Specifies the port to listen on for incoming WebSocket traffic. --rpc-port Specifies the port to listen on for incoming RPC traffic. --telemetry-url Specifies where to send telemetry data. --validator Specifies that this node participates in block production and finalization for the network. --rpc-methods Specifies the RPC methods to allow. The Unsafe setting allows unsafe communication methods because this blockchain is not being used in a production setting. --name Specifies a human-readable name for the node that you can view in the telemetry user interface. For more information about the command-line options that are available for the node template, see the usage help by running the following command: ./target/release/node-template --help Verify that you see output similar to the following: bash 2021-11-03 15:32:14 Substrate Node 2021-11-03 15:32:14 \u270c\ufe0f version 3.0.0-monthly-2021-09+1-bf52814-x86_64-macos 2021-11-03 15:32:14 \u2764\ufe0f by Substrate DevHub <https://github.com/substrate-developer-hub>, 2017-2021 2021-11-03 15:32:14 \ud83d\udccb Chain specification: My Custom Testnet 2021-11-03 15:32:14 \ud83c\udff7 Node name: MyNode01 2021-11-03 15:32:14 \ud83d\udc64 Role: AUTHORITY 2021-11-03 15:32:14 \ud83d\udcbe Database: RocksDb at /tmp/node01/chains/local_testnet/db 2021-11-03 15:32:14 \u26d3 Native runtime: node-template-100 (node-template-1.tx1.au1) 2021-11-03 15:32:15 \ud83d\udd28 Initializing Genesis block/state (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) 2021-11-03 15:32:15 \ud83d\udc74 Loading GRANDPA authority set from genesis on what appears to be first startup. 2021-11-03 15:32:15 \u23f1 Loaded block-time = 6s from block 0x6c78abc724f83285d1487ddcb1f948a2773cb38219c4674f84c727833be737de 2021-11-03 15:32:15 Using default protocol ID \"sup\" because none is configured in the chain specs 2021-11-03 15:32:15 \ud83c\udff7 Local node identity is: 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX 2021-11-03 15:32:15 \ud83d\udce6 Highest known block at #0 2021-11-03 15:32:15 \u303d\ufe0f Prometheus exporter started at 127.0.0.1:9615 2021-11-03 15:32:15 Listening for new connections on 127.0.0.1:9945. 2021-11-03 15:32:20 \ud83d\udca4 Idle (0 peers), best: #0 (0x6c78\u202637de), finalized #0 (0x6c78\u202637de), \u2b07 0 \u2b06 0 In the output, take note of the following information: The initial or genesis block that the node is using is (state: 0x2bde\u20268f66, header-hash: 0x6c78\u202637de) . When you start the next node, verify that these values are the same. The node identity is 12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX . The IP address is 127.0.0.1 . The peer-to-peer (p2p) port is --port = 30333 . These values are for this specific tutorial example. The values will be different for your node and you must provide the values for your node to other network participants to connect to the bootnode.","title":"Start the first blockchain node"},{"location":"tutorials/start-a-private-network/#add-keys-to-the-keystore","text":"After you start the first node, no blocks are yet produced. The next step is to add two types of keys to the keystore for each node in the network. For each node: Add the aura authority keys to enable block production . Add the grandpa authority keys to enable block finalization . There are several ways you can insert keys into the keystore. For this tutorial, you can use the key subcommand to insert locally-generated secret keys. To insert keys into the keystore: Open a terminal shell on your computer. Change to the root directory where you compiled the Substrate node template. Insert the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 \\ --password-interactive \\ --key-type aura This example uses the secret seed generated from the key subcommand into the keystore. You can also insert a key from a specified file location. For information about the command-line option available, run the following command: bash ./target/release/node-template key insert --help Insert the grandpa secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node01 \\ --chain customSpecRaw.json \\ --suri 0x563d22ef5f00e589e07445a3ad88bb92efaa897d7f73a4543d9ac87476434e65 \\ --password-interactive \\ --key-type gran Verify that your keys are in the keystore for node01 by running the following command: bash ls /tmp/node01/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04 6772616e1441ddcb22724420b87ee295c6d47c5adff0ce598c87d3c749b776ba9a647f04","title":"Add keys to the keystore"},{"location":"tutorials/start-a-private-network/#enable-other-participants-to-join","text":"You can now allow other validators to join the network using the --bootnodes and --validator command-line options. To add a second validator to the private network: Open a terminal shell on a second computer. Change to the root directory where you compiled the Substrate node template. Purge old chain data, if needed, by running the following command: bash ./target/release/node-template purge-chain --base-path /tmp/node02 --chain local -y Start a second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url \"wss://telemetry.polkadot.io/submit/ 0\" \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Add the aura secret key generated from the key subcommand by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f \\ --password-interactive \\ --key-type aura Note that this command uses the second participant's secret key and that the aura key type is required to enable block production. Add the grandpa secret key generated from the key subcommand to the local keystore by running a command similar to the following: bash ./target/release/node-template key insert --base-path /tmp/node02 \\ --chain customSpecRaw.json \\ --suri 0x0087016ebbdcf03d1b7b2ad9a958e14a43f2351cd42f2f0a973771b90fb0112f \\ --password-interactive \\ --key-type gran Note that this command uses the second participant's secret key and that the gran key type is required to enable block finalization. Block finalization requires at least two-thirds of the validators to add their keys to their respective keystores. Because this network is configured with two validators in the chain specification, block finalization starts after the second node has added its keys. Verify that your keys are in the keystore for node02 by running the following command: bash ls /tmp/node02/chains/local_testnet/keystore The command displays output similar to the following: bash 617572611a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 6772616e1a4cc824f6585859851f818e71ac63cf6fdc81018189809814677b2a4699cf45 Substrate nodes require a restart after inserting a grandpa key, so you must shut down and restart nodes before you see blocks being finalized. Shut down the node by pressing Control-c. Restart the second blockchain node by running the following command: bash ./target/release/node-template \\ --base-path /tmp/node02 \\ --chain ./customSpecRaw.json \\ --port 30334 \\ --ws-port 9946 \\ --rpc-port 9934 \\ --telemetry-url 'wss://telemetry.polkadot.io/submit/ 0' \\ --validator \\ --rpc-methods Unsafe \\ --name MyNode02 \\ --bootnodes /ip4/127.0.0.1/tcp/30333/p2p/12D3KooWLmrYDLoNTyTYtRdDyZLWDe1paxzxTw5RgjmHLfzW96SX Note that the command includes the base-path and name command-line options plus an additional validator option to specify that this node is a validator for the private network. Also note that all validators must be using identical chain specifications to peer. Be sure to set the correct bootnode identifier in the command. If you don't set the correct bootnode identifier, you see errors like this: \ud83d\udc94 The bootnode you want to connect to at ... provided a different peer ID than the one you expect: ... After both nodes have added their keys to their respective keystores and been restarted, you should see the same genesis block and state root hashes. You should also see that each node has one peer ( 1 peers ), and they have produced a block proposal ( best: #2 (0xe111\u2026c084) ). After a few seconds, you should see new blocks being finalized. ```bash ```","title":"Enable other participants to join"},{"location":"tutorials/start-a-private-network/#next-steps","text":"You have now seen how you can start a private blockchain with trusted participants. In this tutorial you learned: How to start and stop peer blockchain nodes. How to generate your own secret key pairs. How to create a custom chain specification that uses the keys you generated. How to add validators to a private network that uses your custom chain specification. To learn more about the topics introduced in this tutorial, see the following sections: Executor for more information about the WebAssembly runtime that is a core component of the chain specification. Accounts and Key management for more information about key generation and storage options. Cryptography for more information about the signature schemes used for different keys.","title":"Next steps"}]}